<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.ProgramSynthesis</name>
    </assembly>
    <members>
        <member name="T:Microsoft.ProgramSynthesis.AST.Parser.NamespaceDoc">
            <summary>
                Generated parser for loading <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> objects from human-readable text.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Parser.IASTListener">
            <summary>
            This interface defines a complete listener for a parse tree produced by
            <see cref="T:Microsoft.ProgramSynthesis.AST.Parser.ASTParser"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.EnterClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTListener.ExitClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener">
            <summary>
            This class provides an empty implementation of <see cref="T:Microsoft.ProgramSynthesis.AST.Parser.IASTListener"/>,
            which can be extended to create a listener which only needs to handle a subset
            of the available methods.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Enter a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Exit a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Enter a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Exit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            <para>The default implementation does nothing.</para>
            </summary>
            <param name="context">The parse tree.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.EnterEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.ExitEveryRule(Antlr4.Runtime.ParserRuleContext)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.VisitTerminal(Antlr4.Runtime.Tree.ITerminalNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseListener.VisitErrorNode(Antlr4.Runtime.Tree.IErrorNode)">
            <inheritdoc/>
            <remarks>The default implementation does nothing.</remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1">
            <summary>
            This interface defines a complete generic visitor for a parse tree produced
            by <see cref="T:Microsoft.ProgramSynthesis.AST.Parser.ASTParser"/>.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1.VisitClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1">
            <summary>
            This class provides an empty implementation of <see cref="T:Microsoft.ProgramSynthesis.AST.Parser.IASTVisitor`1"/>,
            which can be extended to create a visitor which only needs to handle a subset
            of the available methods.
            </summary>
            <typeparam name="Result">The return type of the visit operation.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitConstructorExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ConstructorExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ConstructorExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitValueExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>ValueExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitLetExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LetExpressionContext)">
            <summary>
            Visit a parse tree produced by the <c>LetExpression</c>
            labeled alternative in <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitExpression(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ExpressionContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.expression"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.value"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitSymbolicValue(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolicValueContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbolicValue"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.LiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.literal"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitArray(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ArrayContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.array"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitTuple(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.TupleContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.tuple"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitDictionary(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.DictionaryContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.dictionary"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitKv(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.KvContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.kv"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitOptional(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.OptionalContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.optional"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitPrimitiveLiteral(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.PrimitiveLiteralContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.primitiveLiteral"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitHole(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.HoleContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.hole"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitSymbol(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.SymbolContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.symbol"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Parser.ASTBaseVisitor`1.VisitClassId(Microsoft.ProgramSynthesis.AST.Parser.ASTParser.ClassIdContext)">
            <summary>
            Visit a parse tree produced by <see cref="M:Microsoft.ProgramSynthesis.AST.Parser.ASTParser.classId"/>.
            <para>
            The default implementation returns the result of calling <see cref="M:Antlr4.Runtime.Tree.AbstractParseTreeVisitor`1.VisitChildren(Antlr4.Runtime.Tree.IRuleNode)"/>
            on <paramref name="context"/>.
            </para>
            </summary>
            <param name="context">The parse tree.</param>
            <return>The visitor result.</return>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.NamespaceDoc">
            <summary>
                Classes for representing programs in memory,
                which are made out of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> and its subclasses.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Extensions.NamespaceDoc">
            <summary>
                Helper methods for <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> defined in <see cref="T:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PreTraverse(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Action{Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, starting with itself. Returns this for chaining purposes.
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to traverse.</param>
            <param name="action">The function to apply to every program node</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PreMap(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode},Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
             Transforms a programNode to another using the given function.
             Clones the programNode if the transformation returned null.
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to transform.</param>
            <param name="transformation">The function which applied to (parent, indexInParent, this) returns a programNode if this should be change, and null otherwise</param>
            <param name="parent">The parent of this node</param>
            <param name="indexInParent">The index where it appears in his parent</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.PostTraverse(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Action{Microsoft.ProgramSynthesis.AST.ProgramNode})">
            <summary>
             Applies a callback to each descendant, ending with itself
            </summary>
            <param name="program">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to traverse.</param>
            <param name="action">The function to apply to every program node</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.Extensions.ProgramNodeExtensions.AddConversionRules(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Creates a new program node starting at <paramref name="symbol"/> by adding conversion rules to <paramref name="program"/>.
            </summary>
            <param name="program"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to wrap in conversions.</param>
            <param name="symbol">Output symbol.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> of <paramref name="program" /> and conversions to <paramref name="symbol" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.StdLiteralParsing">
            <summary>
            Contains a set of utility methods for parsing literal values, produced by <see cref="N:Microsoft.ProgramSynthesis"/>.
            Values of primitive .NET types and arrays are parsed natively. User-defined types are parsed using the methods 
            <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseXML"/> and <see cref="P:Microsoft.ProgramSynthesis.Utils.ParseableAttribute.ParseHumanReadableString"/> in the associated
            <see cref="T:Microsoft.ProgramSynthesis.Utils.ParseableAttribute"/> instance for the expected type.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.ASTSerializationFormat">
            <summary>
                The format of serialization of AST into strings. Used in
                <see cref="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Parse(System.String,Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.AST.ProgramNode.GrammarRule">
            <summary>
            Returns the grammar rule associated with this node, or null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.AcceptVisitor``1(Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor{``0})">
            <summary>
            Returns the value computed by the hierarchical application of the <paramref name="visitor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Parse(System.String,Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
            Parses a string of the grammar symbol <paramref name="symbol"/> that was deserialized in a <paramref name="format"/> 
            into a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>/>.
            If the <paramref name="format"/> is human readable, the string must be deserialized from the same grammar (or parsing will fail).
            </summary>
            <param name="ast">The deserialized program.</param>
            <param name="symbol">The symbol corresponding to <paramref name="ast"/>.</param>
            <param name="format">The serialization format.</param>
            <returns>The program node.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AST.ProgramNode.Parse(System.String,Microsoft.ProgramSynthesis.Grammar,Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
            Parses a string that was deserialized in a <paramref name="format"/> into a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> according to the <paramref name="grammar"/>.
            If the <paramref name="format"/> is human readable, the string must be deserialized from the same grammar (or parsing will fail).
            </summary>
            <param name="ast">The deserialized program.</param>
            <param name="grammar">The grammar.</param>
            <param name="format">The serialization format.</param>
            <returns>The program node.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.HumanReadablePrintVisitor">
            <summary>
            <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor`1"/> implementation used to get human readable representation of a
            program node.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.NamespaceDoc">
            <summary>
                Visitors for printing an AST in either human-readable (<see cref="T:Microsoft.ProgramSynthesis.AST.Visitors.HumanReadablePrintVisitor"/>)
                or XML (<see cref="T:Microsoft.ProgramSynthesis.AST.Visitors.XmlPrintVisitor"/>) format.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.AST.Visitors.XmlPrintVisitor">
            <summary>
            <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNodeVisitor`1"/> implementation used to get an <see cref="T:System.Xml.Linq.XElement"/> representation of a program node.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_ReferenceNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_ReferenceNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Referenced file not found: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeLocationNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is public and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeLocationNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Type {0} is not found in any of the referenced assemblies. Check that it is public and is in scope of all imported namespaces.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeIsNotStatic">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Type {0} should be a public static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_TypeIsNotStatic.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Type {0} should be a public static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_MemberNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is public and static.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_MemberNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Member {0} not found in the specified class {1}. Check that it is public and static.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownReferenceType">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe), Microsoft.ProgramSynthesis compiled grammars (.grammar.xml).&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownReferenceType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Cannot load a reference from the file &apos;{0}&apos;. Currently supported references are: .NET assemblies (.dll/.exe), Microsoft.ProgramSynthesis compiled grammars (.grammar.xml).&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Unknown external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownSymbol">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UnknownSymbol.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_AssemblyNotFound">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Could not resolve an assembly name &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_AssemblyNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Could not resolve an assembly name &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_CompilationFailed">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Could not compile grammar assembly.  Compiler messages: {0}&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_CompilationFailed.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Could not compile grammar assembly.  Compiler messages: {0}&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_InvalidRuleName">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_InvalidRuleName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Member {0} references invalid rule name &apos;{1}&apos;. This rule does not exist in the language {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UndeclaredExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Undeclared external language: &apos;{0}&apos;. Use &apos;using grammar &lt;name&gt;=&lt;class&gt;.&lt;property&gt;&apos; to refer to a previously compiled grammar&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_UndeclaredExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Undeclared external language: &apos;{0}&apos;. Use &apos;using grammar &lt;name&gt;=&lt;class&gt;.&lt;property&gt;&apos; to refer to a previously compiled grammar&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_DuplicateExternalGrammar">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Duplicate external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Core_DuplicateExternalGrammar.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Duplicate external language: &apos;{0}&apos;.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownFeature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_UnknownFeature.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Feature &apos;{0}&apos; was not found in the language {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_IncompatibleCalculatorReturnType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In the feature calculator {0}, return type {1} cannot be converted to the required feature type {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a public function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoFeatureCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No &apos;{0}&apos; feature calculator was found for the rule {1}. Please define a public function in the class {2} and mark it with [FeatureCalculator] attribute.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoLearningInfoParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type LearningInfo as the first parameter.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_NoLearningInfoParameter.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Expected a learning info parameter of type LearningInfo as the first parameter.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedNonterminalCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In nonterminal feature calculator {0}, parameter &apos;{1}&apos; has type {2}, expected a type derived from ProgramNode.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedLiteralCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Literal feature calculator {0} has {1} parameters, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_ExpectedRecursiveCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, parameter &apos;{2}&apos; has type {3}, expected {4}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_AmbiguousFeatureCalculator.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous &apos;{0}&apos; feature calculator for the rule {1}: cannot choose between {2} and {3}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_InvalidRuleName">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, the rule name &apos;{2}&apos; is invalid. Rule names must be valid C# identifiers (may contain only alphanumeric symbols and underscores).&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_InvalidRuleName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In feature &apos;{0}&apos; calculator {1}, the rule name &apos;{2}&apos; is invalid. Rule names must be valid C# identifiers (may contain only alphanumeric symbols and underscores).&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_VarDefaultNotGiven">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Implementation {0} of a complete feature &apos;{1}&apos; does not override the default implementation of {2}, which calculates the value of this feature on variable nodes. {3} will be used instead in order to make the feature complete. If this is not intentional, either remove the @complete annotation or override the method with your implementation&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Features_VarDefaultNotGiven.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Implementation {0} of a complete feature &apos;{1}&apos; does not override the default implementation of {2}, which calculates the value of this feature on variable nodes. {3} will be used instead in order to make the feature complete. If this is not intentional, either remove the @complete annotation or override the method with your implementation&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_SymbolCircularDependency.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Circular symbol dependency detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoStartSymbols">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoStartSymbols.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No start symbols found. Please mark one of the nonterminals of the language as @start.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneStart">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneStart.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;More then one start symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoInputSymbols">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoInputSymbols.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;No input symbols found. Please mark one of the terminals of the language as @input.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneInput">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_MoreThanOneInput.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;More then one input symbol detected: {0}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_ConceptParametersShouldBeArguments.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;In concept rule {0}, the set of formal parameters {1} on the left-hand side should be equal to the set of the unbound symbols {2} on the right-hand side.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_IncompatibleSymbolTypes.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Symbol {0} has type {1}, but is initialized with a symbol {2}, which has type {3}&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoLanguageName">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No language name found.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_NoLanguageName.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No language name found.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_DuplicateId">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Id {0} was already declared.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Syntax_DuplicateId.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Id {0} was already declared.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_NoSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;public static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_NoSemantics.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;No semantics found for the rule {0}. Expected a function with signature &apos;public static {1} {0}({2})&apos; in any of the semantics locations.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_AmbiguousSemantics.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Ambiguous semantics for the rule {0}: cannot choose between {1} and {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleSemanticsReturnType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Semantics function {0} returns {1}, expected {2}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptArgumentType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; expects an argument of type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.Semantics_IncompatibleConceptResultType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Invalid type {0} of symbol {1}: the concept &apos;{2}&apos; returns a type {3} here.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_PlanNotFound">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Plan class {0} is not found in any of the referenced assemblies. Check that it is a public static class.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_PlanNotFound.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Plan class {0} is not found in any of the referenced assemblies. Check that it is a public static class.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IgnoredTerminalWitnesses">
            <summary>
            Represents a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IgnoredTerminalWitnesses.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces a warning message similar to: &quot;Illegal witness function specification for the terminal rule {0}, ignored.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessRuleType">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessRuleType.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} expects rule type {1} as its first parameter, but the rule {2} has type {3}, which cannot be converted to {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessSignature">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has a signature that does not derive from (GrammarRule rule, Spec outerSpec, [, Spec prereqs...]) -&gt; Spec.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessSignature.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has a signature that does not derive from (GrammarRule rule, Spec outerSpec, [, Spec prereqs...]) -&gt; Spec.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessPrereqTypes">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has invalid prerequisite type(s). They must occur after the required GrammarRule and Spec and be in a single parameter of type Spec[] or a series of parameters of types deriving from Spec.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessPrereqTypes.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has invalid prerequisite type(s). They must occur after the required GrammarRule and Spec and be in a single parameter of type Spec[] or a series of parameters of types deriving from Spec.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessParameter">
            <summary>
            Represents a diagnostic that produces an error message similar to: &quot;Witness function {0} has a parameter specification that is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic.DeductiveLearning_IncompatibleWitnessParameter.#ctor(Microsoft.ProgramSynthesis.Diagnostics.Location,System.Object[])">
            <summary>
            Constructs a diagnostic that produces an error message similar to: &quot;Witness function {0} has a parameter specification that is out of range of valid parameters for the body of the rule {1}.&quot;
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.NamespaceDoc">
            <summary>
                Error and warning messages emitted by dslc are of type <see cref="T:Microsoft.ProgramSynthesis.Diagnostics.Diagnostic"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Diagnostics.Result`1">
            <summary>
            Represents a result of a computation that can fail, along with a list of diagnostics, collected during a computation.
            For a successful result, the property <see cref="P:Microsoft.ProgramSynthesis.Diagnostics.Result`1.Value"/> contains the result of computation, null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.AssemblyResolution.Load(System.String)">
            <remarks>
                This overload is required to enable assembly resolution on older versions of .NET/Mono.
                Without it, our compiled languages call <c>Array.Empty&lt;string&gt;</c> to instantiate
                <c>libraryPaths</c>, which is missing in older versions of mscorlib.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IFeature.GetFeatureValueForVariable(Microsoft.ProgramSynthesis.AST.VariableNode)">
            <summary>
                Calculates the value of the feature represented by the current instance
                for a given <see cref="T:Microsoft.ProgramSynthesis.AST.VariableNode" /> program <paramref name="variable" />.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IFeature.Calculate(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.Features.LearningInfo)">
            <summary>
                Calculates the value of this feature for <paramref name="program" /> possibly using the additional information in
                <paramref name="learningInfo" />. This method is responsible for calling
                <see cref="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.LearningInputs,Microsoft.ProgramSynthesis.AST.ProgramNode)" /> on its
                <paramref name="learningInfo" /> argument with <paramref name="program" />.
            </summary>
            <param name="program"><see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to compute feature value on.</param>
            <param name="learningInfo">Optional additional <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> the feature calculator may use.</param>
            <returns>The value of this feature for <paramref name="program" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Feature`1.GetFeatureValueForVariable(Microsoft.ProgramSynthesis.AST.VariableNode)">
            <summary>
                Calculates the value of the feature represented by the current instance
                for a given <see cref="T:Microsoft.ProgramSynthesis.AST.VariableNode" /> program <paramref name="variable" />.
            </summary>
            <param name="variable"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Feature`1.FeatureInfoResolution.Declared">
            <summary>
                Consider only features that are defined in the language grammar.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Feature`1.FeatureInfoResolution.CreateIfMissing">
            <summary>
                Find a feature with the given name in the language grammar. If missing, create a new
                <see cref="T:Microsoft.ProgramSynthesis.FeatureInfo" /> from the provided parameters.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Feature`1.FeatureInfoResolution.AlwaysCreate">
            <summary>
                Create a new <see cref="T:Microsoft.ProgramSynthesis.FeatureInfo" /> from the provided parameters, ignoring the language grammar.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.FeatureInfo.IsComplete">
            <summary>
            Complete features must be defined on the entire grammar.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FeatureMissingException">
            <summary>
            Thrown when attempting to lookup a feature that is not defined in a given <see cref="P:Microsoft.ProgramSynthesis.FeatureMissingException.Grammar"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.FeatureUndefinedException">
            <summary>
                Thrown when attempting to calculate a feature on a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> 
                for which that feature is undefined.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.LearningInfo">
            <summary>
                Information about the learning session to be given to a <see cref="T:Microsoft.ProgramSynthesis.FeatureCalculator" /> that requests it. This
                wraps a <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.LearningInputs" /> and the <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> whose feature is being computed, so the
                <see cref="T:Microsoft.ProgramSynthesis.FeatureCalculator" /> may invoke the program on the inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.LearningInputs">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.LearningInputs" /> for the learning call this corresponds to.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> whose feature is currently being computed.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputs(Microsoft.ProgramSynthesis.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.InputKind" /> of inputs to run
                <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>The outputs of <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetInputOutputPairs(Microsoft.ProgramSynthesis.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs and returns the inputs and outputs. Note
                that this returns an <see cref="T:System.Collections.Generic.IEnumerable`1" />; the program may not be invoked until the
                <see cref="T:System.Collections.Generic.IEnumerable`1" /> is actually enumerated.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.InputKind" /> of inputs to run <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>
                <see cref="T:System.Collections.Generic.KeyValuePair`2" />s where the keys are the <paramref name="kind" /> inputs and the values are
                their outputs on <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputMapping(Microsoft.ProgramSynthesis.InputKind)" />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetOutputMapping(Microsoft.ProgramSynthesis.InputKind)">
            <summary>
                Runs <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on the <paramref name="kind" /> inputs and returns a dictionary mapping the inputs
                to the outputs.
            </summary>
            <param name="kind">
                Which <see cref="T:Microsoft.ProgramSynthesis.InputKind" /> of inputs to run <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" /> on.
            </param>
            <returns>
                A dictionary mapping the <paramref name="kind" /> inputs to their outputs on <see cref="P:Microsoft.ProgramSynthesis.Features.LearningInfo.ProgramNode" />.
            </returns>
            <seealso cref="M:Microsoft.ProgramSynthesis.Features.LearningInfo.GetInputOutputPairs(Microsoft.ProgramSynthesis.InputKind)" />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Features.LearningInfoUtils">
            <summary>
                Utility functions for <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.LearningInputs,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Returns a <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> wrapping <paramref name="learningInputs" /> and
                <paramref name="programNode" />.
            </summary>
            <param name="learningInputs">The <see cref="T:Microsoft.ProgramSynthesis.LearningInputs" /> with the inputs to the learning call.</param>
            <param name="programNode">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to provide information for.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object to be passed to a <see cref="T:Microsoft.ProgramSynthesis.FeatureCalculator" /> for
                <paramref name="programNode" />.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Features.LearningInfoUtils.WithProgramNode(Microsoft.ProgramSynthesis.Features.LearningInfo,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Constructs a new <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> with the same <see cref="T:Microsoft.ProgramSynthesis.LearningInputs" /> as
                <paramref name="learningInfo" /> but a different <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />.
            </summary>
            <param name="learningInfo">The <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> with the inputs to the learning call.</param>
            <param name="programNode">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to provide information for.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object to be passed to a <see cref="T:Microsoft.ProgramSynthesis.FeatureCalculator" /> for
                <paramref name="programNode" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.LearningInputs">
            <summary>
                The information about inputs provided to a <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.TopK(Microsoft.ProgramSynthesis.IFeature,System.Int32,Microsoft.ProgramSynthesis.LearningInputs)" /> call. This separates the inputs from
                specifications (<see cref="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs" />) from the additional inputs (<see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AdditionalInputs" />) into
                separate lists as well as providing a list with both (<see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AllInputs" />). <see cref="T:Microsoft.ProgramSynthesis.FeatureCalculator" />s
                are passed this wrapped in a <see cref="T:Microsoft.ProgramSynthesis.Features.LearningInfo" /> object which also includes the <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                the feature is being calculated on so the output values can be computed.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.LearningInputs._hashCode">
            <summary>
                Cached hashcode.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.LearningInputs.#ctor(System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State},System.Collections.Generic.IReadOnlyList{Microsoft.ProgramSynthesis.State})">
            <summary>
                Constructs a <see cref="T:Microsoft.ProgramSynthesis.LearningInputs" /> object wrapping the inputs to a learning call.
            </summary>
            <param name="specInputs">The inputs from the specifications.</param>
            <param name="additionalInputs">The additional inputs for which there might be no specification.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.AdditionalInputs">
            <summary>
                Additional inputs for which no specification is given (note these are not guaranteed to be distinct from
                <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputsSet">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.AdditionalInputsSet">
            <summary>
                Additional inputs for which no specification is given (note these are not guaranteed to be distinct from
                <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs" />).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.AllInputs">
            <summary>
                All known inputs; the concatenation of distinct values from <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs" /> and
                <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AdditionalInputs" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.Empty">
            <summary>
                An empty <see cref="T:Microsoft.ProgramSynthesis.LearningInputs" /> object representing no known inputs.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.LearningInputs.AllInputsCount">
            <summary>
                The number of inputs in <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AllInputs" />. This may be approximate if <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AllInputs" /> has not been
                accessed yet.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.LearningInputs.Equals(Microsoft.ProgramSynthesis.LearningInputs)">
            <summary>Indicates whether the current object is equal to another object of the same type.</summary>
            <returns>true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.</returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.LearningInputs.GetInputs(Microsoft.ProgramSynthesis.InputKind)">
            <summary>
                Returns the inputs of the specified <paramref name="kind" />.
            </summary>
            <param name="kind">The <see cref="T:Microsoft.ProgramSynthesis.InputKind" /> to select.</param>
            <returns>The specification, additional, or all inputs depending on <paramref name="kind" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.LearningInputs.GetHashCode">
            <summary>Serves as the default hash function. </summary>
            <returns>A hash code for the current object.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.InputKind">
            <summary>
                Identifies the three sets of inputs.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.InputKind.Spec">
            <summary>
                Inputs that appear in the specification (usually examples) in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.InputKind.Additional">
            <summary>
                Additional inputs for which no specification is given (note these are not guaranteed to be distinct from
                <see cref="F:Microsoft.ProgramSynthesis.InputKind.Spec" />).
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.InputKind.All">
            <summary>
                All known inputs; the concatenation of distinct values from <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.SpecInputs" /> and
                <see cref="P:Microsoft.ProgramSynthesis.LearningInputs.AdditionalInputs" />.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute.Verify">
            <summary>
            True if the produced spec does not guarantee compositional equivalence of the learned program spaces
            for the rule parameters, and the composed programs should be verified.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Grammar.DeclaringProperty">
            <summary>
                If this grammar is parsed from another assembly, then this contains the full
                name of the property that contains a reference to it; otherwise, <c>null</c>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Grammar.CalculateFreeVariableHeight(Microsoft.ProgramSynthesis.Symbol,System.Collections.Immutable.ImmutableDictionary{Microsoft.ProgramSynthesis.Symbol,System.Int32},System.Collections.Immutable.ImmutableDictionary{Microsoft.ProgramSynthesis.Symbol,System.Int32},System.Int32)">
            <summary>
            Perform a DFS on the grammar, starting from <paramref name="current"/>.
            As usual in a DFS, keep track of visited symbols (with the number of times they were visited) in <paramref name="seen"/>.
            Also, for each symbol, keep track of the longest path (as measured by variable bindings) from <see cref="P:Microsoft.ProgramSynthesis.Grammar.StartSymbol"/>
            to this symbol in <paramref name="longestPaths"/>.
            This is needed for detecting cycles with bindings, which cause infinite <see cref="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight"/>.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight">
            <summary>
            Returns the maximal number of free variables that can appear in any path from the root to leaves, 
            or <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing"/> if it can be infinite.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Metrics.NormalizedDiscountedCumulativeGain">
            <summary>
                Evaluate the NDCG@k score relevance-scored collections.
                <see>https://en.wikipedia.org/wiki/Discounted_cumulative_gain</see>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Metrics.NormalizedDiscountedCumulativeGain.Evaluate(System.Int32,System.Double[])">
            <summary>
            Evaluate NDCK@k on a concrete array of relevance scores.
            </summary>
            <param name="k">a non-zero truncation limit (i.e. ideal top k)</param>
            <param name="relevances">non-negative relevance scores</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.NamespaceDoc">
            <summary>
                Contains classes common to all uses of DSLs.
                <see cref="T:Microsoft.ProgramSynthesis.Grammar"/> and <see cref="T:Microsoft.ProgramSynthesis.Symbol"/> for defining DSLs
                and <see cref="T:Microsoft.ProgramSynthesis.FeatureInfo"/> for definition properties over DSLs.
                <see cref="T:Microsoft.ProgramSynthesis.State"/> is used for interpreting programs.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.IProgram">
            <summary>
                The interface for all programs, which wraps a <see cref="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode" /> with type information so it's more
                convenient to use.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.IProgram.ProgramNode" /> object which contains the actual program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.Score">
            <summary>
                The ranking score of the program (the higher the better).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.IProgram.Version">
            <summary>
                The version of the program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationFormat">The desired serialization format (XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Describe(System.Globalization.CultureInfo)">
            <summary>
                Describes the functionality of the program at a high level.
                Returns null if program description is not available.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <returns>The program description (null if not available)</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.IProgram.Run(System.Object)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The program's output.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Program`2">
            <summary>
                A program in a DSL.
                This wraps a <see cref="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode" /> with type information so it's more convenient to use.
            </summary>
            <typeparam name="TInput">The input type of the program.</typeparam>
            <typeparam name="TOutput">The output type of the program.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Double)">
            <summary>
                Constructs a program wrapping <paramref name="programNode" /> with the score <paramref name="score" />.
            </summary>
            <param name="programNode">The program to wrap.</param>
            <param name="score">The ranking score of <paramref name="programNode" />.</param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode">
            <summary>
                The <see cref="P:Microsoft.ProgramSynthesis.Program`2.ProgramNode" /> object which contains the actual program.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.Score">
            <summary>
                The ranking score of the program (the higher the better).
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Program`2.Version">
            <summary>
                The version of the program.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Equals(Microsoft.ProgramSynthesis.Program{`0,`1})">
            <summary>
                Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
                true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="obj">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.ToString">
            <summary>
                Prints the internal program node in human-readable format.
            </summary>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Serialize(Microsoft.ProgramSynthesis.AST.ASTSerializationFormat)">
            <summary>
                Serializes the program to a string.
            </summary>
            <param name="serializationFormat">The desired serialization format (XML or human-readable).</param>
            <returns>The serialized program.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Describe(System.Globalization.CultureInfo)">
            <summary>
                Describes the functionality of the program at a high level.
                Returns null if program description is not available.
            </summary>
            <param name="cultureInfo">The culture info.</param>
            <returns>The program description (null if not available)</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Microsoft#ProgramSynthesis#IProgram#Run(System.Object)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The program's output.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Program`2.Run(`0)">
            <summary>
                Executes the program on the <paramref name="input" /> to obtain the output.
            </summary>
            <param name="input">The input.</param>
            <returns>The output.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Extensions.ConversionRulesTo(Microsoft.ProgramSynthesis.Symbol,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Finds a list of conversion rules to convert <paramref name="original" /> to <paramref name="target" />.
            </summary>
            <param name="original">The original symbol.</param>
            <param name="target">The target symbol.</param>
            <returns>
                The rules to convert <paramref name="original" /> to <paramref name="target" />
                or an empty list if no such rules exist or <paramref name="original" /> is already
                a <paramref name="target"/>.
            </returns>
            <remarks>If multiple paths exist, this returns an arbitrary one of shortest length.</remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule.GetParameterPositionInConcept(System.Int32)">
            <summary>
            Given a parameter index in the DSL operator, returns the position of the corresponding child in the concept implementation 
            as a coordinate path.
            </summary>
            <param name="dslParameterIndex">The index of the requested child in the list of DSL operator parameters</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptParameterUsage">
            <summary>
            Describe usage properties of a parameter of a concept rule as an argument in its concept implementation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.ParameterUsage">
            <summary>
            How the formal parameter corresponds to the concept argument? It can be either used directly as an argument
            symbol, or passed on to the argument symbol as a child (if the argument symbol is a lambda symbol or another
            concept).
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot">
            <summary>
                Removes elements from a set that satisfy a predicate, i.e.,
                FilterNot(\x => pred(x), list) = { x | x \in list, !pred(x) }.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.Predicate">
            <summary>
                The eliminating predicate.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.Concepts.FilterNot.Set">
            <summary>
                The elements.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.Kth">
            <summary>
            Kth(L, k) selects the kth element from the sequence L.
            If k is non-negative, we select the element in the forward order (starting from 0 for the 1st element, 1 for the 2nd element, and so on).
            If k is negative, we select the element in the backward order (starting from -1 for the last element, -2 for the penultimate element, and so on)
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.Concepts.NamespaceDoc">
            <summary>
                Functions common to many DSLs are defined using <see cref="T:Microsoft.ProgramSynthesis.Rules.Concepts.ConceptRule"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.Intersect(Microsoft.ProgramSynthesis.ILanguage)">
            <summary>
                Intersects <paramref name="other" /> with this language. The implicit assumption is that <paramref name="other" />
                is a subset of the language defined by the <see cref="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.Grammar" /> that this rule is associated with.
            </summary>
            <param name="other">The language to intersect with.</param>
            <returns>A language corresponding to the intersection of <code>this</code> with <paramref name="other" />.</returns>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Rules.GrammarRule.RecursionLimit">
            <summary>
            A list of recursion limits for each body parameter;
            <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing"/> if the parameter is not recursive, or recursion is unlimited.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.AddStandardWitnessFunction(Microsoft.ProgramSynthesis.Learning.WitnessFunction.Static.Delegate,System.Int32,Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute)">
            <summary>
                Add a standard witness function by means of a delegate specifying its behavior
            </summary>
            <remarks>
                For this delegate case, <paramref name="attr" /> must be specified because the delegate won't be
                carrying any useful custom attributes.
            </remarks>
            <param name="witnessFunction">A delegate specifying the behavior of the witness function</param>
            <param name="parameter">The index of the parameter being learned</param>
            <param name="attr">Attribute containing metadata about the witness function</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.GrammarRule.AddStandardWitnessFunction(System.Linq.Expressions.Expression{System.Action},System.Int32,Microsoft.ProgramSynthesis.Learning.WitnessFunctionAttribute)">
            <summary>
                Add a standard witness function by means of an <see cref="T:System.Linq.Expressions.Expression"></see>.
            </summary>
            <param name="surroundWitnessFunction">
                An <see cref="T:System.Linq.Expressions.Expression"></see> used to specify the witness function.  It must be
                of the form <c>() => TheWitnessFunction(ignoredParameters)</c>.  This method will extract the method
                being called and discard the remainder of the <see cref="T:System.Linq.Expressions.Expression"></see>.
            </param>
            <param name="parameter">The index of the parameter being learned</param>
            <param name="attr">Attribute containing metadata about the witness function</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.NamespaceDoc">
            <summary>
                Classes for representing DSL grammars (<see cref="T:Microsoft.ProgramSynthesis.Grammar"/>) in memory,
                which are made out of <see cref="T:Microsoft.ProgramSynthesis.Rules.GrammarRule"/> and its subclasses.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Rules.NonterminalRule.ValidStateFromArgumentInvocations(System.Tuple{Microsoft.ProgramSynthesis.State,System.Object}[])">
            <summary>
            Constructs a valid State with which this rule should have been invoked to produce the given 
                <param name="argumentInvocations">states and values</param>
                for its parameter invocations.
            </summary>
            <returns>Null if the given states are incompatible with the rule logic; a valid State otherwise.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Rules.OperatorRule.OperatorSemantics">
            <summary>
            The semantics of an operator rule: f(N, ..., N)  = f(N , ..., N ).
            Such a function does not change its given state  during execution, therefore it is not given this state explicitly.
            </summary>
            <param name="args">The values of the evaluated argument nodes: [N , ..., N ].</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.ExampleWithNegativesSpec.TransformInputs(System.Func{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.State})">
            <summary>
            Produces a copy of this <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> where the provided inputs are transformed with a given
            transformer function <paramref name="transformer"/>, and the associated constrains on the inputs remain the same.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.Extensions.NamespaceDoc">
            <summary>
                Helper methods for <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> and related types.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec">
            <summary>
                Defines a specification on a program output that has type <see cref="T:System.Func`2" />.
                For each input state in <see cref="P:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.Relation" />, it holds a set of disjunctive input-output examples
                that constrain the behavior of the program output (which is a function).
                This function, given an input value stored as a key of <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />,
                must return one of the output values stored as the values of <see cref="T:System.Collections.Generic.MultiValueDictionary`2" />.
            </summary>
            <example>
                The following <see cref="T:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec" /> defines a function that compares a given input
                with the value of the variable <c>v</c> stored in the input <see cref="T:Microsoft.ProgramSynthesis.State" />, and returns
                <c>-1</c>, <c>0</c>, or <c>1</c> if the input is less that, equal, or greater than <c>v</c>, respectively.
                <code>
                    var v = grammar.Symbol("v");
                    var relation = new Dictionary&lt;State, MultiValueDictionary&lt;object, object&gt; {
                        [State.Create(v, 7)] = new MultiValueDictionary&lt;object, object&gt; {
                            {1, {-1, 0}}, {6, {-1}}, {7, {-1, 0}}, {8, {1}}
                        },
                        [State.Create(v, -2)] = new MultiValueDictionary&lt;object, object&gt; {
                            {0, {1}}, {-2, {-1, 0}}
                        }
                    };
                    var spec = new FunctionalDisjunctiveOutputSpec(relation);
                    spec.CorrectOnProvided(State.Create(v, 7), x => x.CompareTo(7));  // true
                    spec.CorrectOnProvided(State.Create(v, 7), x => x + 1));          // false
                </code>
            </example>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.From``1(System.Collections.Generic.IDictionary{Microsoft.ProgramSynthesis.State,``0})">
            <summary>
                Creates a new <see cref="T:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.CorrectOnProvided(Microsoft.ProgramSynthesis.State,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.EqualsOnInput(Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.GetHashCodeOnInput(Microsoft.ProgramSynthesis.State)">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.InputToXML(Microsoft.ProgramSynthesis.State,System.Collections.Generic.Dictionary{System.Object,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.TransformInputs(System.Func{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.State})">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.NullToBottom">
            <inheritdoc />
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.FunctionalDisjunctiveOutputSpec.BottomToNull">
            <inheritdoc />
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec">
            <summary>
                An ExampleSpec which keeps count of duplicate examples as well.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.#ctor(System.Collections.Generic.IReadOnlyDictionary{Microsoft.ProgramSynthesis.State,System.Collections.Generic.KeyValuePair{System.Object,System.UInt32}})">
            <summary>
                Instantiates a new <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from counts of examples.
            </summary>
            <param name="examplesWithCounts">Dictionary of states mapped to the result and count.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.KeyValuePair{System.Object,System.UInt32}}})">
            <summary>
                Instantiates a new <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from counts of examples.
            </summary>
            <param name="examplesWithCounts">
                An Enumerable of KeyValuePairs with states mapped to the result and count.
            </param>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.ExamplesWithCounts">
            <summary>
                Dictionary of states mapped to the result and count.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec.FromExamples(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Object}},System.Collections.Generic.IEqualityComparer{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Object}})">
            <summary>
                Construct a new instance of <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" /> from an enumerable of examples which may have
                duplicates, and an equality comparer.
            </summary>
            <param name="examples">An enumerable of examples.</param>
            <param name="equalityComparer">An equality comparer for examples.</param>
            <returns>
                An instance of <see cref="T:Microsoft.ProgramSynthesis.Specifications.GroupedExamplesSpec" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.NamespaceDoc">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> and subclasses for conditions a learned program is expected to satisfy.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs">
            <summary>
                The input states this spec is defined on.
                For each input in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" /> the spec stores some constraint that
                the desired program output should satisfy.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnProvided(Microsoft.ProgramSynthesis.State,System.Object)">
            <summary>
                Checks if <paramref name="output" /> satisfies this spec on a given input <paramref name="state" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Checks if all the <paramref name="outputs" /> satisfy this spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(System.Object)">
            <summary>
                Checks if <paramref name="output" /> satisfies this spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnAllProvided(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Checks if the given <paramref name="program" /> satisfies this spec by invoking it on all the provided
                inputs in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" /> and checking the outputs using <see cref="M:Microsoft.ProgramSynthesis.Specifications.Spec.CorrectOnProvided(Microsoft.ProgramSynthesis.State,System.Object)" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.Valid(Microsoft.ProgramSynthesis.State,System.Object)">
            <summary>
                Checks if the <paramref name="output" /> satisfies this spec on a given <paramref name="input" />.
                If <paramref name="input" /> is not present in <see cref="P:Microsoft.ProgramSynthesis.Specifications.Spec.ProvidedInputs" />, this method conservatively
                returns <c>true</c> without any verification.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.EqualsOnInput(Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                For a given input <paramref name="state" />, checks if the content of this spec is the same
                as in the <paramref name="other" /> given spec.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.GetHashCodeOnInput(Microsoft.ProgramSynthesis.State)">
            <summary>
                Computes a hash code of the content of this spec associated with a given <paramref name="state" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.NullToBottom">
            <summary>
                Returns a copy of this spec where all instances of <c>null</c> in the output constraints
                are replaced with the special value <see cref="T:Microsoft.ProgramSynthesis.Utils.Bottom" />.
            </summary>
            <remarks>
                A typical implementation makes use of the helper method <see cref="M:Microsoft.ProgramSynthesis.Utils.ObjectUtils.NullToBottom(System.Object)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.BottomToNull">
            <summary>
                Returns a copy of this spec where all instances of <see cref="T:Microsoft.ProgramSynthesis.Utils.Bottom" /> in the output constraints
                are replaced with <c>null</c>.
            </summary>
            <remarks>
                A typical implementation makes use of the helper method <see cref="M:Microsoft.ProgramSynthesis.Utils.ObjectUtils.BottomToNull(System.Object)" />.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.InputToXML(Microsoft.ProgramSynthesis.State,System.Collections.Generic.Dictionary{System.Object,System.Int32})">
            <summary>
                Returns an XML representation of the content of this spec
                associated with a given <paramref name="input" /> state.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.Spec.TransformInputs(System.Func{Microsoft.ProgramSynthesis.State,Microsoft.ProgramSynthesis.State})">
            <summary>
                Produces a copy of this <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> where the provided inputs are transformed with a given
                <paramref name="transformer" /> function, and the associated constrains on the inputs remain the same.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.PrefixSpec">
            <summary>
                An output of the program is a sequence of objects. This specification provides: (a) a prefix of the output on a
                given input, and (b) a set of the negative examples on a given input which the output should not intersect with.
                An output of the program is a sequence of objects. This spec provides a prefix of the output on a given input. An
                invocation of a program on the same input is valid if the example output is the prefix of the program's output, and
                the output does not intersect with the negative examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a specification with the prefix and optional negative examples on a single input.
            </summary>
            <param name="input">The input state.</param>
            <param name="prefix">The prefix of the output.</param>
            <param name="negativeExamples">The optional negative examples.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object}}})">
            <summary>
                Creates a specification with only the prefix.
                <param name="prefix">The prefix of the output.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Tuple{System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object}}}})">
            <summary>
                Creates a specification with both prefix and negative examples.
                <param name="examples">The tuples of prefix and negative examples.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.PrefixSpec.ToString">
            <summary>
                Returns the string representation.
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.DisjunctiveSubsequenceSpec">
            <summary>
                An output of the program is a set of objects.
                A spec provides possible subsets of the output on a given input.
                An invocation of a program on the same input
                is valid if its output is a superset of one of the example outputs.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec">
            <summary>
                An output of the program is a set of objects.
                This specification provides: (a) a subset of the output on a given input, and (b) a set of the negative examples on
                a given input which
                the output should not intersect with. An invocation of a program on the same input
                is valid if its output is a superset of the example output, and the output does not intersect with the negative
                examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
                Creates a specification with positive examples and optional negative examples on a single input.
            </summary>
            <param name="input">The input state.</param>
            <param name="positiveExamples">The positive examples.</param>
            <param name="negativeExamples">The optional negative examples.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Collections.Generic.IEnumerable{System.Object}}})">
            <summary>
                Creates a specification with only positive examples.
                <param name="positiveExamples">The positive examples.</param>
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.State,System.Tuple{System.Collections.Generic.IEnumerable{System.Object},System.Collections.Generic.IEnumerable{System.Object}}}})">
            <summary>
                Creates a specification with both positive and negative examples.
                <param name="examples">The tuples of positive and negative examples.</param>
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.PositiveExamples">
            <summary>
                The positive examples.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.NegativeExamples">
            <summary>
                The negative examples.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Specifications.SubsequenceSpec.ToString">
            <summary>
                Returns the string representation.
            </summary>
            <returns>The string representation</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.TopSpec">
            <summary>
                A trivial spec that stores no inputs, and is satisfied by any program.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Specifications.WithInputTopSpec">
            <summary>
                A trivial spec that contains several inputs and is satisfied by any program.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.State.SmallStateThreshold">
            <summary>
            States that hold fewer than <see cref="F:Microsoft.ProgramSynthesis.State.SmallStateThreshold"/> variables are stored as <see cref="T:Microsoft.ProgramSynthesis.State.SmallState"/>
            with <see cref="T:System.Collections.Immutable.ImmutableList`1"/> for underlying storage. States that hold more variables are stored as
            <see cref="T:Microsoft.ProgramSynthesis.State.BigState"/> with <see cref="T:System.Collections.Immutable.ImmutableDictionary`2"/> for underlying storage.
            The choice of <see cref="T:Microsoft.ProgramSynthesis.State.SmallState"/> vs. <see cref="T:Microsoft.ProgramSynthesis.State.BigState"/> in 
            <see cref="M:Microsoft.ProgramSynthesis.State.Create(System.Collections.Generic.KeyValuePair{Microsoft.ProgramSynthesis.Symbol,System.Object}[])"/>
            is done based on the length of the longest chain of variables bindings that may appear in a given <see cref="T:Microsoft.ProgramSynthesis.Grammar"/>.
            This property is stored as <see cref="P:Microsoft.ProgramSynthesis.Grammar.FreeVariableHeight"/>.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Symbol.TryGetAllPrograms(System.Boolean,System.Boolean)">
            <summary>
                Returns a set of all possible programs in the grammar that this symbol can expand to, or
                <see cref="F:Microsoft.ProgramSynthesis.Utils.Optional`1.Nothing" /> if the set is undefined due to unlimited recursion or unrestricted literals
                without explicit value generators on the leaf level.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1">
            <summary>
                A simple helper class that implements the functionality commmon to all generated functions
            </summary>
            <typeparam name="T">The type used to represent programs in the target language.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1.Parameters">
            <summary>
                The names and types of the parameters that this function accepts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1.ReturnType">
            <summary>
                The return type of this function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1.Optimize">
            <summary>
                Performs any language specific optimizations.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1.GenerateCode">
            <summary>
                Generates a representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1" />,
                where the representation of the code has type <typeparamref name="T" />.
            </summary>
            <returns>A representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Type}},System.Type)">
            <summary>
                Constructor.
            </summary>
            <param name="parameters">The name and types of the parameters to this function.</param>
            <param name="returnType">The return type of this function.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1">
            <summary>
                An interface for representing functions generated during translation.
            </summary>
            <typeparam name="T">The type used to represent programs in the target language.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1.Parameters">
            <summary>
                The names and types of the parameters that this function accepts.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1.ReturnType">
            <summary>
                The return type of this function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1.Optimize">
            <summary>
                Performs any language specific optimizations.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1.GenerateCode">
            <summary>
                Generates a representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1" />,
                where the representation of the code has type <typeparamref name="T" />.
            </summary>
            <returns>A representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.IGeneratedFunction`1" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Module`1">
            <summary>
                A Module can be thought of as a mapping from
                identifiers (of type <typeparamref name="T" />) to representations
                of computations in the target language (also of type <typeparamref name="T" />).
            </summary>
            <typeparam name="T">The type used to represent computations in the target language.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module`1.AppendAuxiliaryCode(System.String,`0)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module`1.ClearAuxiliaryCode">
            <summary>
                Clears any code added via <see cref="M:Microsoft.ProgramSynthesis.Translation.Module`1.AppendAuxiliaryCode(System.String,`0)"/> to this module.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module`1.TryGetAuxiliaryCode(System.String,`0@)">
            <summary>
                Retrieve a previously registered auxiliary code unit. See <see cref="M:Microsoft.ProgramSynthesis.Translation.Module`1.AppendAuxiliaryCode(System.String,`0)" />.
            </summary>
            <param name="name">The name used to previously register the code unit using <see cref="M:Microsoft.ProgramSynthesis.Translation.Module`1.AppendAuxiliaryCode(System.String,`0)" />.</param>
            <param name="code">An out parameter for the returned code.</param>
            <returns>
                <c>true</c> if the lookup was a success (and the value of <paramref name="code" /> is set to the desired code.
                <c>false</c> otherwise, and <paramref name="code" /> is not guaranteed to be set to anything meaningful.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module`1.GenerateCode(`0)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <param name="headerModuleReference">
                A reference to a header module that the code in this module is dependent on.
            </param>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Module`1.GenerateUnisolatedCode(`0)">
            <summary>
                Generates unisolated code, i.e., code that executes/lives in the global namespace,
                provided subclasses override this method appropriately.
                The default behavior is to call <see cref="M:Microsoft.ProgramSynthesis.Translation.Module`1.GenerateCode(`0)" />.
            </summary>
            <param name="headerModuleReference">
                A references to a header module that the code in this module is dependent on.
            </param>
            <returns>A representation of the code corresponding to this module.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1">
            <summary>
                A class that represents an opaque generated function.
                Useful when the definition of the function in the target
                language is already known or is easier to generated directly,
                rather than go through the SSA mechanism of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction`1" />.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1.FunctionCode">
            <summary>
                The representation of the code for the function.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Type}},System.Type,`0)">
            <summary>
                Constructor.
            </summary>
            <param name="parameters">The name and types of the parameters to this function.</param>
            <param name="returnType">The return type of this function.</param>
            <param name="functionCode">The representation of the code for this function.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1.GenerateCode">
            <summary>
                Generates a representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1" />,
                where the representation of the code has type <typeparamref name="T" />.
            </summary>
            <returns>A representation of the code for this <see cref="T:Microsoft.ProgramSynthesis.Translation.OpaqueGeneratedFunction`1" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.GenerateCode(System.String)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <param name="headerModuleReference">
                The name of the header module. Unused in the case of
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule" />.
            </param>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.GenerateUnisolatedCode(System.String)">
            <summary>
                Generates unisolated code, i.e., code that executes/lives in the global namespace.
            </summary>
            <param name="headerModuleReference">
                The name of the header module. Unused in the case of
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule" />.
            </param>
            <returns>A programmatic representation of the code corresponding to this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonHeaderModule.AppendAuxiliaryCode(System.String,System.String)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the 
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.GenerateCode(System.String)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.GenerateUnisolatedCode(System.String)">
            <summary>
                Generates unisolated code, i.e., code that executes/lives in the global namespace,
                provided subclasses override this method appropriately.
                The default behavior is to call <see cref="M:Microsoft.ProgramSynthesis.Translation.Module`1.GenerateCode(`0)" />.
            </summary>
            <param name="headerModuleReference">
                A reference to the header module that the code in this module is dependent on.
            </param>
            <returns>A representation of the code corresponding to this module.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonModule.AppendAuxiliaryCode(System.String,System.String)">
            <summary>
                Add arbitrary text as auxiliary code. This code will be output before the code for any of the
                generated functions. The default implementation throws an exception. Subclasses need to implement
                this method as required.
            </summary>
            <param name="codeUnitName">The name for this unit of code.</param>
            <param name="auxiliaryCode">A representation of the auxiliary code.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonGeneratedFunction.GenerateCode">
            <summary>
                Generates code for this function. This code need not be "executable"
                in and of itself if the target language does not treat functions as
                first class "values".
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3">
            <summary>
                A base translator for Python code generation. DSL specific translators need to subclass
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3" />. Like
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Translator`6" />, this
                class isn't thread safe as well.
            </summary>
            <typeparam name="TProgram">The type of the program to translate.</typeparam>
            <typeparam name="TProgramInput">The type of the input to <typeparamref name="TProgram" />.</typeparam>
            .
            <typeparam name="TProgramOutput">The type of the output generated by <typeparamref name="TProgram" />.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3.GenerateHeaderModule(`0,System.String)">
            <summary>
                Generates a module containing the header (if any) for
                the given program <see cref="!:p" />.
                The header can include any definitions required for the generated
                program corresponding to <see cref="!:p" /> to execute.
            </summary>
            <param name="p">A generated program</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Translation.Module`1" /> which contains the definitions that all code generated by this translator can
                implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3.GenerateLiteralRepresentation(System.Object,System.Type)">
            <summary>
                Generates the representation of the literal in the target language.
            </summary>
            <param name="literalValue">An <see cref="T:System.Object" /> representing the value of the literal.</param>
            <param name="literalType">The type of the literal.</param>
            <returns>
                A representation of <see cref="!:literalValue" /> interpreted as a value
                of the type <see cref="!:literalType" /> in the target language.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3.GenerateFunctionBody(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Generates an implementation for a lambda.
            </summary>
            <param name="formalParameters">The formal parameters to the function: A mapping from names to types.</param>
            <param name="returnType">The return type of the function.</param>
            <param name="functionBody">The program node corresponding to the body of the function.</param>
            <returns>
                A representation of the function as a value, that can be used to call the function.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3.CreateModule(System.String)">
            <summary>
                Creates a new module with the given name.
            </summary>
            <param name="moduleName">The name of the module to create.</param>
            <returns>A new <see cref="T:Microsoft.ProgramSynthesis.Translation.Module`1" /> named <see cref="!:moduleName" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Python.PythonTranslator`3.Translate(`0,Microsoft.ProgramSynthesis.Translation.Module{System.String},System.String)">
            <summary>
                Translates a program <paramref name="root" /> into a representation of a function corresponding to the program
                <paramref name="root" />.
            </summary>
            <param name="root">The program to be translated.</param>
            <param name="translationModule">The module into which all lambdas in the program will be placed.</param>
            <param name="headerModuleReference">
                The name of the module in which any auxiliary functions required for this program
                are assumed to reside. e.g. semantics for various operators, any datatypes required by the program, etc.
            </param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1" /> that corresponds to the translation of the program
                <paramref name="root" />.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.R.RHeaderModule">
            <summary>
                Implements the common functionality required by all DSLs for translation to R.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RHeaderModule.GenerateCode(System.String)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.R.RModule">
            <summary>
                A module for R programs.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RModule.GenerateCode(System.String)">
            <summary>
                Generates code for all the functions that have been bound to a name in this module.
            </summary>
            <returns>A representation of the code for this module.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3">
            <summary>
                A base translator for R code generation. DSL specific translators need to subclass
                <see cref="T:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3" />. Like
                <see cref="T:Microsoft.ProgramSynthesis.Translation.Translator`6" />, this
                class isn't thread safe as well.
            </summary>
            <typeparam name="TProgram">The type of the program to translate.</typeparam>
            <typeparam name="TProgramInput">The type of the input to <typeparamref name="TProgram" />.</typeparam>
            .
            <typeparam name="TProgramOutput">The type of the output generated by <typeparamref name="TProgram" />.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3.#ctor">
            <summary>
                Constructor
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3.GenerateHeaderModule(`0,System.String)">
            <summary>
                Generates the header (if any) for the given program <see cref="!:p" />
                The header can include any definitions required for the generated
                program corresponding to <see cref="!:p" /> to execute.
            </summary>
            <param name="p">A generated program.</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>A <see cref="T:Microsoft.ProgramSynthesis.Translation.Module`1" /> containing the program header.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3.GenerateLiteralRepresentation(System.Object,System.Type)">
            <summary>
                Generates the representation of the literal in the target language.
            </summary>
            <param name="literalValue">An <see cref="T:System.Object" /> representing the value of the literal.</param>
            <param name="literalType">The type of the literal.</param>
            <returns>
                A representation of <see cref="!:literalValue" /> interpreted as a value
                of the type <see cref="!:literalType" /> in the target language.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.R.RTranslator`3.GenerateFunctionBody(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Generates an implementation for a lambda.
            </summary>
            <param name="formalParameters">The formal parameters to the function: A mapping from names to types.</param>
            <param name="returnType">The return type of the function.</param>
            <param name="functionBody">The body of the function.</param>
            <returns>
                A representation of the function as a value, that can be used to call the function.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction`1">
            <summary>
                A class that contains the generated function as a sequence of SSA steps, which
                can then be translated to the target language.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSARegister`1">
            <summary>
                An SSA register represents locations of type <typeparamref name="T" />,
                and essentially wraps them in an object which also contains information
                about the step in the SSA program where it was defined, the steps where
                the register is used, and the registers that are used in the definition
                of this register.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister`1.Name">
            <summary>
                The name of this register.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister`1.Definition">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep`1" /> where this register was defined.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister`1.Uses">
            <summary>
                The collection of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep`1" />s where this definition
                is used.
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.SSARegister`1.DependentOn">
            <summary>
                The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSARegister`1" />s that are used in the definition of
                this register. Note that this does NOT represent the transitive closure
                of the SSA dependence graph.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister`1.#ctor(`0,Microsoft.ProgramSynthesis.Translation.SSAStep{`0})">
            <summary>
                Constructor.
            </summary>
            <param name="name">The name of this register.</param>
            <param name="definition">The <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep`1" /> where this register is defined.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister`1.ToString">
            <summary>
                Returns a string that represents the current object.
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister`1.Equals(System.Object)">
            <summary>
                Determines whether the specified object is equal to the current object.
            </summary>
            <returns>
                true if the specified object  is equal to the current object; otherwise, false.
            </returns>
            <param name="other">The object to compare with the current object. </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSARegister`1.GetHashCode">
            <summary>
                Serves as the default hash function.
            </summary>
            <returns>
                A hash code for the current object.
            </returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.SSAStep`1">
            <summary>
                An <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAStep`1" /> represents a definition of an SSA register.
            </summary>
            <typeparam name="T">The type of the program representation used in the definition of the register.</typeparam>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.SSAStep`1.#ctor(Microsoft.ProgramSynthesis.Translation.SSARegister{`0},`0,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Translation.SSARegister{`0}})">
            <summary>
                Constructor
            </summary>
            <param name="lValue">The register that is being defined.</param>
            <param name="rValue">The representation of the program fragment used to defined this register.</param>
            <param name="registersReferencedInRValue">
                The set of SSA registers that are referenced in the definition of this
                register.
            </param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.StringBasedGeneratedFunction">
            <summary>
                A specialization of <see cref="T:Microsoft.ProgramSynthesis.Translation.SSAGeneratedFunction`1" />, when
                the type used to represent the program is <see cref="T:System.String" />.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Target">
            <summary>
                An enumerated type that describes the language to be targeted during translation.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Target.Python">
            <summary>
                The Python3 programming language.
            </summary>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.Translation.Target.R">
            <summary>
                The R programming language.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.Translation.Translator`6">
            <summary>
                An Abstract Base Class for translating generated programs in some DSL
                into some target programming language. This class (and all its descendants)
                is not thread safe.
            </summary>
            <typeparam name="T">
                The output that this translator emits.
                e.g. string, AST in the target language, etc.
            </typeparam>
            <typeparam name="THeaderModule">The type of the header module.</typeparam>
            <typeparam name="TModule">The type of the main program module.</typeparam>
            <typeparam name="TProgram">The type of the typed program.</typeparam>
            <typeparam name="TProgramInput">The type of the input to the program.</typeparam>
            <typeparam name="TProgramOutput">The type of the output that the program generates.</typeparam>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Translator`6.TargetLanguageName">
            <summary>
                The name of the target language
            </summary>
        </member>
        <member name="P:Microsoft.ProgramSynthesis.Translation.Translator`6.CodeContextStack">
            <summary>
                Intended for subclasses to store a representation the generated code.
                A stack is used to emulate different contexts.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateNewName(System.String,System.String)">
            <summary>
                Generates a fresh name
            </summary>
            <param name="prefix">A string that is to be used as prefix. This defaults to "t_".</param>
            <param name="suffix">A string that is to be used as suffix. Defaults to the empty string.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PushCodeContext">
            <summary>
                Pushes a new "context" for code. Useful for generating blocks of
                code that are to be manipulated atomically.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PopCodeContext">
            <summary>
                Pops a code context. Generally useful for building nested blocks of
                code in combination with <see cref="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PushCodeContext" />.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PeekCodeContext">
            <summary>
                Does what the label says.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.CreateModule(`0)">
            <summary>
                Creates a new module with the given name.
            </summary>
            <param name="moduleName">The name of the module to create.</param>
            <returns>A new <typeparamref name="TModule" /> named <see cref="!:moduleName" />.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateHeaderModule(`3,System.String)">
            <summary>
                Generates a module containing the header (if any) for
                the given program <see cref="!:p" />.
                The header can include any definitions required for the generated
                program corresponding to <see cref="!:p" /> to execute.
            </summary>
            <param name="p">A generated program.</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <typeparamref name="THeaderModule" /> which contains the definitions that all code
                generated by this translator can implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateHeaderModule(System.String)">
            <summary>
                Generate a (possibly suboptimal) header that would work for all programs that
                may be translated using this translator.
            </summary>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>
                A <typeparamref name="THeaderModule" /> which contains the definitions that all code
                generated by this translator can implicitly depend on.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateHeader(`3,System.String)">
            <summary>
                Generates a representation of the header directly.
            </summary>
            <param name="p">The program to generate the header for.</param>
            <param name="headerModuleName">The name of the header module.</param>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateUnisolatedHeader(`3)">
            <summary>
                Generates a representation of the header directly.
                The generated header code is not isolated.
            </summary>
            <param name="p">The program to generate the header for.</param>
            <returns>A representation of the unisolated header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateHeader(System.String)">
            <summary>
                Generates a representation of the header directly. The generated header is independent of the program, and is
                guaranteed to be sufficient for any program generated in the DSL.
            </summary>
            <param name="headerModuleName">The name of module in which the code is to be inserted.</param>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateUnisolatedHeader">
            <summary>
                Generates a representation of the header directly. The generated header is independent of the program, and is
                guaranteed to be sufficient for any program generated in the DSL. The generated header is also not isolated.
            </summary>
            <returns>A representation of the header code.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateOperatorApplication(System.String,System.Collections.Generic.IEnumerable{Microsoft.ProgramSynthesis.Translation.SSARegister{`0}})">
            <summary>
                Generates an application of the operator named <see cref="!:operatorName" />
                with <see cref="!:arguments" /> as its arguments.
            </summary>
            <param name="operatorName">The name of the operator which is to be applied</param>
            <param name="arguments">The arguments to the operator <see cref="!:operatorName" /></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateLiteralRepresentation(System.Object,System.Type)">
            <summary>
                Generates the representation of the literal in the target language.
            </summary>
            <param name="literalValue">An <see cref="T:System.Object" /> representing the value of the literal.</param>
            <param name="literalType">The type of the literal.</param>
            <returns>
                A representation of <see cref="!:literalValue" /> interpreted as a value
                of the type <see cref="!:literalType" /> in the target language.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.GenerateFunctionBody(System.Collections.Generic.IEnumerable{System.Tuple{System.String,System.Type}},System.Type,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Generates an implementation for a lambda.
            </summary>
            <param name="formalParameters">The formal parameters to the function: A mapping from names to types.</param>
            <param name="returnType">The return type of the function.</param>
            <param name="functionBody">The program node corresponding to the body of the function.</param>
            <returns>
                A representation of the function as a value, that can be used to call the function.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PushBindingScope(System.Collections.Generic.IDictionary{System.String,Microsoft.ProgramSynthesis.Translation.SSARegister{`0}})">
            <summary>
                Pushes a new variable resolution scope and adds any new bindings to the scope.
            </summary>
            <param name="newBindings">An optional set of bindings to be added to the new scope.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.PopBindingScope">
            <summary>
                Pops the most recently pushed variable resolution scope.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.ResolveVariable(System.String)">
            <summary>
                Resolves a variable to its binding, according to lexical scoping rules.
            </summary>
            <param name="variableName">The name of the variable whose binding is sought.</param>
            <returns>A representation of the value that the variable <see cref="!:variableName" /> is bound to.</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.BindVariable(System.String,Microsoft.ProgramSynthesis.Translation.SSARegister{`0},System.Boolean)">
            <summary>
                Bind a variable named <see cref="!:variableName" /> to a value represented by <see cref="!:binding" />.
            </summary>
            <param name="variableName">The name of the variable to be bound.</param>
            <param name="binding">
                A representation of the value that the variable <see cref="!:variableName" />
                is to be bound to.
            </param>
            <param name="ignoreIfAlreadyBoundInScope">
                Do not replace the binding if the variable <see cref="!:variableName" /> is
                already bound in this scope.
            </param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.Translate(`3,Microsoft.ProgramSynthesis.Translation.Module{`0},`0)">
            <summary>
                Generates a function which contains the code corresponding to the translation of the program
                <paramref name="root" />.
            </summary>
            <param name="root">The program to be translated.</param>
            <param name="translationModule">The module into which lambdas that this function depends on will be placed.</param>
            <param name="headerModuleReference">
                A reference to the header module which contains code that this function can depend
                on.
            </param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.Translation.GeneratedFunction`1" /> which represents the translation of the program <paramref name="root" />
                .
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.Translation.Translator`6.Translate(`3,`0,`0)">
            <summary>
                Generates a representation of the code corresponding to a program <paramref name="root" />. The function will be
                named <paramref name="generatedFunctionIdentifier" />, and the generated code will be unisolated.
            </summary>
            <param name="root">The program to translate.</param>
            <param name="generatedFunctionIdentifier">
                The identifier for the function generated for the program
                <paramref name="root" />.
            </param>
            <param name="headerModuleReference">A reference to header module which contains code that this module is dependent on.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.JoinProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.NamespaceDoc">
            <summary>
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> and subclasses for compactly representing a set of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule">
            <summary>
                A rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter"/> will use to rewrite programs
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.RewriteRule.#ctor(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Constructs a rewrite rule that <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter"/> will use to rewrite
                <paramref name="source" /> to <paramref name="target" /> where the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are
                reference equal in the two are filled in with the corresponding values.
            </summary>
            <param name="source">Pattern to match.</param>
            <param name="target">Pattern to rewrite to.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter">
            <summary>
                Algorithm for rewriting one pattern of <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to another.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.RewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> to rewrite.</param>
            <param name="rewriteRule">
                The rewrite rule that consists of a source to be found in <paramref name="input"/> and a target
                to replace it with.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> with all occurrences of <paramref name="rewriteRule"/>'s source
                replaced by <paramref name="rewriteRule"/>'s target.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.RewriteRule)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" />
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" />s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole" /> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> to rewrite.</param>
            <param name="rewriteRule">
                The rewrite rule that consists of a source to be found in <paramref name="input" /> and a target
                to replace it with.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode" /> with all occurrences of <paramref name="rewriteRule" />'s source
                replaced by <paramref name="rewriteRule" />'s target.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Rewrite(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Rewrite a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> by replacing occurrences of a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>
                pattern with another one.  The pattern may contain <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s which are copied
                as-is to the result.
            </summary>
            <remarks>
                The source and target patterns may not contain a particular <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> more than
                once.  This is not checked.
            </remarks>
            <param name="input">The <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to rewrite.</param>
            <param name="source">The pattern to find in <paramref name="input"/>.</param>
            <param name="target">
                The pattern that will replace <paramref name="source"/> in <paramref name="input"/>.
            </param>
            <returns>
                The rewritten <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> with all occurrences of
                <paramref name="source"/> replaced by <paramref name="target"/>.
            </returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Extract(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@)">
            <summary>
                Splits a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> into programs that match a pattern and those that don't.
            </summary>
            <remarks>
                Implements the <c>Extract</c> algorithm from the OneNote page.
            </remarks>
            <param name="input">The program set to split.</param>
            <param name="pattern">The pattern to split <paramref name="input"/> on</param>
            <param name="matched">The programs in <paramref name="input"/>that match <paramref name="pattern"/>.</param>
            <param name="unmatched">The programs in <paramref name="input"/>that don't match <paramref name="pattern"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.CreateUnmatchedCartesianProduct(Microsoft.ProgramSynthesis.Rules.NonterminalRule,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[],Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[],Microsoft.ProgramSynthesis.VersionSpace.ProgramSet[])">
            <summary>
                Create the set of programs that correspond to <paramref name="rule"/> applied to arguments
                in <paramref name="matchedParameters"/> and <paramref name="unmatchedParameters"/>.  Each
                program must include at least one non-empty instance from <paramref name="unmatchedParameters"/>.
            </summary>
            <remarks>
                <paramref name="originalParameters"/> is the original union of <paramref name="matchedParameters"/>
                and <paramref name="unmatchedParameters"/>.  It is provided to avoid reconstructing its members. 
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformNode(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
             <summary>
                 Produce a new <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> from <paramref name="target"/> by performing a unification
                 on values in <paramref name="input"/> and <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in <paramref name="source"/> and
                 substituting them in it.
             </summary>
             <remarks>
                 Implements the <c>TransformNode</c> algorithm from the OneNote page.
            
                 Precondition: <paramref name="input"/> matches <paramref name="source"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformSet(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
             <summary>
                 Produce a new <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> from <paramref name="target"/> by performing a unification
                 on values in <paramref name="input"/> and <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in <paramref name="source"/> and
                 substituting them in it.
             </summary>
             <remarks>
                 Implements the <c>TransformSet</c> algorithm from the OneNote page.
            
                 Precondition: All programs in <paramref name="input"/> match <paramref name="source"/>.
             </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.Matches(Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Determine if <paramref name="input"/> unifies with <paramref name="pattern"/>.
                Unification allows syntactic matching as well as arbitrary nodes to correspond to
                <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeInSetHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeInNodeHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetInSetHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
                This may promote <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s with that <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> to
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.SetInNodeHoleFiller">
            <summary>
                Substitute a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> for a <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> in a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
                This may promote <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>s with that <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/> to
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>s.
            </summary>
            <remarks>
                If the value is a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/> with a single program, then the substitution
                extracts that program and the result remains a <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet">
            <summary>
                Identify the minimal sub-<see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> (or <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>) that
                contains any of the given set of <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s and transform it given a provided
                transformation method.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet.#ctor(System.Collections.Immutable.IImmutableSet{Microsoft.ProgramSynthesis.AST.Hole},System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Create a visitor that will find the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/> to transform and
                call the supplied transformer on it.
            </summary>
            <remarks>
                <paramref name="transformSet"/> and <paramref name="transformNode"/> are passed in rather
                than directly called to allow the test code to mock them.
            </remarks>
            <param name="filter">The <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s of interest.</param>
            <param name="transformSet">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</param>
            <param name="transformNode">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.</param>
            <param name="input">
                The original input that led to the need for this minimal transformation.  It must be a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet"/> or <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/>.
            </param>
            <param name="source">The original pattern that matched <paramref name="input"/>.</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet.TransformMinimalHelper(System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Helper method for <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramSet"/> and
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode"/> to do the actual transformation.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.UniqueHoleCollector">
            <summary>
                Gather the <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s in a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>, possibly restricting them
                to a filter.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode">
            <summary>
                Identify the minimal sub-<see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> that contains any of the given set of
                <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s and transform it given a provided transformation method.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.TransformMinimalProgramNode.#ctor(System.Collections.Immutable.IImmutableSet{Microsoft.ProgramSynthesis.AST.Hole},System.Func{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Func{Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.AST.ProgramNode,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Create a visitor that will find the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> to transform and
                call the supplied transformer on it.
            </summary>
            <remarks>
                <paramref name="transformSet"/> and <paramref name="transformNode"/> are passed in rather
                than directly called to allow the test code to mock them.
            </remarks>
            <param name="filter">The <see cref="T:Microsoft.ProgramSynthesis.AST.Hole"/>s of interest.</param>
            <param name="transformSet">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.</param>
            <param name="transformNode">Method to transform the minimal <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/>.</param>
            <param name="input">
                The original input that led to the need for this minimal transformation.  It must be a
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet"/> or <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.DirectProgramSet"/>.
            </param>
            <param name="source">The original pattern that matched <paramref name="input"/>.</param>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet">
            <summary>
                Union over <see cref="T:Microsoft.ProgramSynthesis.AST.ProgramNode"/> and <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet"/>.
            </summary>
            <remarks>
                If a <c>null</c> set or node is used, then both <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet.IsSet"/> and
                <see cref="P:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.NodeOrSet.IsNode"/> will return <c>false</c>.
            </remarks>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetVisitor._accessibleSymbols">
            <summary>
                Symbols <see cref="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetRewriter.RewriteSetVisitor._source"/>'s symbol is accessible from.
            </summary>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor`1">
            <summary>
                A visitor for a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> to pass to <see cref="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})" />.
            </summary>
            <typeparam name="T">The return type of this visitor.</typeparam>
        </member>
        <member name="F:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.LeafSetSize">
            <summary>
                The minimum size of a program set that will be represented as a version space algebra.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Intersect(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet)">
            <summary>
                Intersects this program set with another program set <paramref name="other" />, producing a concise
                representation of the program set that consists of all programs in both this program set
                and the <paramref name="other" />.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.FindSetDepthFirst(System.Predicate{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet},System.Predicate{Microsoft.ProgramSynthesis.VersionSpace.ProgramSet})">
            <summary>
                Starting at this program set, traverse the tree of program sets among the first children 
                for which the predicate is true.
                Returns the last program set for which the predicate is true but false for all of its children.
            </summary>
            <param name="predicate">A function telling if the program set is the one we are looking for</param>
            <param name="traverseChildren">Optional: A function telling if we should traverse the set's children</param>
            <returns>The last program set for which the predicate is true but false for all of its children</returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Sample(System.Random)">
            <summary>
                Draw a single program from this program set uniformly at random.
            </summary>
            <param name="random"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Shatter(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext)">
            <summary>
                Partition this program set into subspaces where every program in the set hashes to the same value
                under a universal hash function defined over the program structure.
                <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext" />
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Filter(Microsoft.ProgramSynthesis.Specifications.Spec)">
            <summary>
                Filters this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> down only to a programs that are consistent with a given
                <paramref name="spec" />.
            </summary>
            <param name="spec">A spec to satisfy.</param>
            <returns>
                A <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> representing a subset of the programs contained in the current instance that
                satisfy <paramref name="spec" />.
            </returns>
            <remarks>
                When possible, use the extension method <c>Filter(Spec, SynthesisEngine)</c>
                from <c>Microsoft.ProgramSynthesis.Learning.ProgramSetExtensions</c> instead.
                It has vastly superior performance but may not handle all <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec"/> instances completely.
                If it fails, fall back to this implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.PartitionByValidity(Microsoft.ProgramSynthesis.Specifications.Spec,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@,Microsoft.ProgramSynthesis.VersionSpace.ProgramSet@)">
            <summary>
                Partitions this space of programs into two parts: those that satisfy a spec and those that do not.
            </summary>
            <param name="spec">A <see cref="T:Microsoft.ProgramSynthesis.Specifications.Spec" /> defining the space of valid programs</param>
            <param name="validSet">programs for which the spec holds</param>
            <param name="invalidSet">programs for which the spec does not hold</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.FindChildSet(Microsoft.ProgramSynthesis.AST.ProgramNode,System.Int32)">
            <summary>
                Returns the ProgramSet corresponding to the child; given that this ProgramSet can represent the parent.
            </summary>
            <param name="node">The parent (member of this ProgramSet)</param>
            <param name="indexInParent">The index of child in the parent's children</param>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.Contains(Microsoft.ProgramSynthesis.AST.ProgramNode)">
            <summary>
                Returns true iff this <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> instance contains the given program as a set.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.AddConversionRules(Microsoft.ProgramSynthesis.VersionSpace.ProgramSet,Microsoft.ProgramSynthesis.Symbol)">
            <summary>
                Build a <see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of with symbol <paramref name="symbol" /> which contains just
                <paramref name="body" /> and conversions on top of it.
            </summary>
            <param name="body"><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> to wrap in conversions.</param>
            <param name="symbol">Output symbol.</param>
            <returns><see cref="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSet" /> of <paramref name="body" /> and conversions to <paramref name="symbol" />.</returns>
        </member>
        <member name="T:Microsoft.ProgramSynthesis.VersionSpace.ProgramSetUtils.ShatteringContext">
            <summary>
                A class that organizes how a program set will be shattered using a hash
                function drawn from a universal hash function family. A program will be
                assigned the same hash bucket whether it was represented explicitly or
                implicitly in a VSA.
            </summary>
        </member>
        <member name="M:Microsoft.ProgramSynthesis.VersionSpace.UnionProgramSet.AcceptVisitor``1(Microsoft.ProgramSynthesis.VersionSpace.ProgramSetVisitor{``0})">
            <summary>
                Returns the value computed by the hierarchical application of the <paramref name="visitor" /> instance.
            </summary>
        </member>
    </members>
</doc>
