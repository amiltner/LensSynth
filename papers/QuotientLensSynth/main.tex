\newif\ifdraft\drafttrue  % set true to show comments

\documentclass{svproc}

\usepackage{amsmath, amssymb, verbatim, enumerate, 
graphicx, centernot, tikz, array, tikz-cd, extarrows, cleveref,
mathrsfs, mathtools, bussproofs, stmaryrd, enumitem, stackengine}

%%%%%
% Macros
% Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,0.4}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.5,0.5}
\definecolor{orange}{rgb}{0.9,0.6,0.2}
\definecolor{lightyellow}{RGB}{255, 255, 179}
\definecolor{lightgreen}{RGB}{170, 255, 220}
\definecolor{teal}{RGB}{141,211,199}
\definecolor{darkbrown}{RGB}{121,37,0}

\newcommand{\FINISH}[3]{\ifdraft\textcolor{#1}{[#2: #3]}\fi}
\newcommand{\bcp}[1]{\FINISH{dkred}{B}{#1}}
\newcommand{\BCP}[1]{\FINISH{dkred}{B}{\bf #1}}
\newcommand{\afm}[1]{\FINISH{dkgreen}{A}{#1}}
\newcommand{\dpw}[1]{\FINISH{dkblue}{D}{#1}} % Toronto Maple Leafs Blue :-)
\newcommand{\saz}[1]{\FINISH{orange}{SZ}{#1}}
\newcommand{\ksf}[1]{\FINISH{teal}{K}{#1}}
\newcommand{\sam}[1]{\FINISH{dkpurple}{SM}{#1}}

% FOR Regular Expression names
\newcommand{\re}[1]{\ensuremath{\mathtt{#1}}}
\newcommand{\squash}[3]{\ensuremath{\mathit{squash} \; (#1, #2, #3)}}
\newcommand{\perm}[2]{\ensuremath{\mathit{perm}\; (#1)\; \mathit{with}\; #2}}
\newcommand{\normalize}[3]{\ensuremath{\mathit{normalize} \; (#1, #2, #3)}}
\newcommand{\sep}{\ensuremath{\; | \;}}
\newcommand{\canonizer}{\ensuremath{\mathit{Canonizer}}}



\begin{document}
\mainmatter              % start of a contribution
%
\title{Synthesizing Quotient Lenses}
%
\titlerunning{Synthesizing Quotient Lenses}  % abbreviated title (for running
% head)                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{}
%
\authorrunning{} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{}
%
\institute{}

\maketitle              % typeset the title of the contribution

\begin{abstract}

\keywords{quotient lenses, quotient regular expressions, synthesis}
\end{abstract}

\section{Introduction}

{\em Lens programming languages} such as
Boomerang~\cite{Boomerang}\bcp{and others!} enable programmers to kill two
birds in one stone by expressing both directions of a bidirectional
transformation with a single program.  

\bcp{
  \begin{itemize}
  \item Small example of a boomerang program (maybe in our syntax)
  \item Discussion of lens laws.
  \end{itemize}
}

However, the constraints that are imposed by the lens laws are sometimes too
strict. 
For instance, the programmer may wish to ignore updates to the data that only
change the order of fields, or add whitespace characters that in reality are not
part of the data. Foster et al therefore proposed \textit{quotient lenses} as a
solution to this problem. Quotient lenses enable a programmer to write lenses
which transform data that is quotiented out by an equivalence relation, so that
records which are equivalent to each other modulo this relation are considered
the same by the underlying lens.

\dpw{The next paragraph gets at the problem, but takes a while to do
so.  Why not make the first sentence go directly to the problem:  ``Unfortunately,
quotient lens programs are unnecessarily verbose and challenging to construct.'' ... or
something like that.}

This paper addresses two main challenges that arise when programming quotient
lenses. The first challenge is tied directly to the programming of quotient
lenses in Boomerang, a string lens programming language where the source and
view types are given by regular expressions. While Boomerang enables the
programmer to express a rich set of quotient lenses, the syntax for writing
these lenses is often too verbose and cumbersome. This makes writing quotient
lenses in Boomerang rather difficult.

For example, suppose that the programmer wishes to convert citation records
stored in \textsc{Bib}\TeX{} format to a representation of the same data in the
EndNote format. The programmer wishes to ``quotient'' away unnecessary
whitespace characters in between the various fields in each record, while also
ignoring the order in which these fields occur in the recore. For instance, the
quotient lens which the programmer wishes to derive should convert this
\textsc{Bib}\TeX{} record

\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
  Publisher = {Printed in GB by William Clowes & Sons Ltd},
  Year = {1971}
}
\end{verbatim}

\noindent to this EndNote record

\begin{verbatim}
%0 Book
%T Regular Algebra and Finite Machines
%A Conway, J. H.
%D 1971
%I Printed in GB by William Clowes & Sons Ltd
%F conway
\end{verbatim}

\noindent and vice versa.

\bcp{Moreover...}
allowing for this equivalent representation of the \textsc{Bib}\TeX{}
entry, which rearranges the fields and uses different whitespace conventions:

\begin{verbatim}
@Book{conway, 
    Publisher = {Printed in GB by 
                 William Clowes & Sons Ltd},
                 
    Title = {Regular Algebra and Finite Machines},
    
    Year = {1971},
    
    Author = {Conway, J. H.},
}
\end{verbatim}
\bcp{Can we write (regular and QRE) lenses that handle this version of the
  example?  Write this in Boomerang and see how it looks!!} 

While Boomerang enables the programmer to write a lens which exhibits this
behaviour, the syntax tree for the program is large and complicated.  

\saz{It might be a good idea to show what this would look like in all its gory
detail, just to make the problem very concrete. Perhaps in a figure?}\bcp{+1}\dpw{+1}
  
In this paper, we introduce the formalism of Quotient Regular Expressions (or
QREs) to address this issue. \dpw{cut unnecessary phrases that add little information
content.  eg, cut ``the formalism of.''  Doing so makes your text ``punchier.''}  QREs enable the programmer to express
a rich set of equivalence relations on regular expressions at the level of
syntax. QREs therefore enable the programmer to express more equivalence
relations with less effort. Also, since QREs are defined at the level of
syntax on regular expressions, QREs give the programmer more control over where
the quotienting occurs.

\bcp{Give a little example (perhaps for Bibtex and/or EndNote?)}

The second challenge that we address in this paper is the {\em synthesis} of
(bijective) quotient lenses. These are quotient lenses which match the
equivalance classes of the source data to the equivalence classes of the view
data bijectively as in the \textsc{Bib}\TeX{} to EndNote example above. 
Building on our prior work~\cite{popl18} where we showed how to synthesize
(ordinary?) bijective lenses, we show how to synthesize bijective quotient
lenses given a synthesis task described by a pair of QREs and a set of
examples. 

Our main contributions are:
\begin{enumerate}
\item We introduce a novel language of {\em Quotient Regular Expressions}
(QREs) that provide compact, convenient notation for a broad class of
equivalence relations on regular languages (Section~\ref{QRE}).
\item We define a language of {\em QRE lenses}, a class of quotient lenses
whose types are given by QREs.  Our main technical contribution is a normal
form for QRE lenses and a proof that QRE lenses in normal form are closed
under left quotienting, right quotienting, composition, and regular
operators (Section~\ref{QRE-lenses}).
\item Using this normal form, we reduce the problem of {\em synthesizing}
QRE lenses from their QRE types and a set of examples to the previously studied
problem of synthesizing bijective lenses between regular languages 
(Section~\ref{synth}).
\item We extend the Boomerang {\em implementation} with QREs, QRE lens operators,
and QRE lens synthesis and demonstrate its applicability by using it to
synthesize QRE lenses between several real-world data formats from the
{\tt data.gov} database (Section~\ref{impl}).
\end{enumerate}
Sections~\ref{relwork} and~\ref{concl} discuss related and future work.

\section{Quotient Regular Expressions}
\label{QRE}

This section introduces Quotient Regular Expressions or QREs. QREs are regular
expressions augmented with syntax that lets them simultaneously express an
equivalence relation on the language described by the regular expression.

  \subsection{Syntax of QREs}
The language of Quotient Regular Expressions (QREs) is given by the following
grammar:
\begin{align*}
q := \; &R \sep R \mapsto s \sep \squash{R}{R'}{f} \sep
\perm{q_1, \ldots, q_n}{q} \;  | \; \normalize{R}{R'}{f}\\
&q' \circ q \sep q \cdot q' \sep (q \sep q') \sep q^*,
\end{align*}
where $R$ ranges over regular expressions, $f$ ranges over functions between
regular languages, and $s$ ranges over character strings.

Each QRE $q$ enables us to express
\begin{enumerate}
  \item a regular expression $W(q)$ (the ``whole'' of $q$),
  \item an equivalence relation $EqRel(q)$ on $\mathcal{L}(W(q))$,
  \item a regular expression $K(q)$ (the ``kernel'' of $q$)
  such that $\mathcal{L}(K(q))$ forms a complete set of representatives for
  $EqRel(q)$, and
  \item a ``canonizing'' function $\canonizer(q):\mathcal{L}(W(q))
  \longrightarrow \mathcal{L}(K(q))$ which given any $w \in \mathcal{L}(W(q))$,
  computes $\canonizer(q)(w)$ as the unique $k$ in $\mathcal{L}(K(q))$ such that
  $k$ is equivalent to $w$ mod $EqRel(q)$
  \end{enumerate}
  Observe that since $\canonizer(q)$ computes $\canonizer(q)(w)$ as the unique
  $k$ in $\mathcal{L}(K(q))$ such that $w$ is equivalent to $k$ mod $EqRel(q)$,
  then the equivalence classes of $EqRel(q)$ are the same as the fibres of
  $\canonizer(q)$.

\dpw{I think it would be a little more effective to introduce QREs with a running,
but informal, concrete example. Explain these concepts informally as you go.
Then summarize the syntax at the end.}

  \subsection{Examples}

\bcp{Give some counterexamples too!  And can we take away the enumerate?}

  \begin{enumerate}
    \item 
    Every regular expression can be lifted to a QRE. When a regular expression
    $R$ is used as a QRE, then $\mathcal{L}(R)$ is assumed to be quotiented by
    the equality equivalence relation on $\mathcal{L}(R)$.
    \item
    For the QRE $R \mapsto s$, the data is described by $\mathcal{L}(R)$, but
    all members of $R$ are considered equivalent to each other, with $s \in
    \mathcal{L}(R)$ as the choice of representative. This construct is useful
    when the programmer simply wishes to ignore unnecessary characters such as
    excess whitespace e.g. 
    $$\mathtt{FIRST\_NAME} \cdot (\mathtt{WHITESPACE}^* \mapsto `` \quad ")
    \cdot \mathtt{LAST\_NAME}$$
    \item
    $\squash{R}{R'}{f}$ enables the programmer to use one of two different
    representations of the data if they can provide a way of mapping the first
    representation to the second. For instance, the first representation may be
    $$\mathtt{FIRST\_NAME} \cdot `` \quad " \cdot \mathtt{LAST\_NAME}$$
    while the second representation may be
    $$\mathtt{FIRST\_NAME} \cdot ``," \cdot \mathtt{LAST\_NAME}$$
    The mapping that maps the first representation to the second simply converts
    the space between the first and last name to a comma.
    \item
    The $\perm{q_1, \ldots, q_n}{q}$ construct enables the programmer to
    consider all permutations of some data that are interspersed with a
    separator the same. For instance, in the \textsc{Bib}\TeX{} to EndNote
    example, the programmer may use this construct as follows:
    $$\perm{\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},
    \re{YEAR}}{(\re{WHITESPACE}^* \mapsto \string \n)}$$
 where $\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},$ and $\re{YEAR}$ are
regular expressions describing the respective \textsc{Bib}\TeX\; fields of the
same name, and $\re{WHITESPACE}$ is a regular expression describing whitespace
characters.
\item
The constructs $q \cdot q'$, $q \sep q'$ and $q^*$ are similar to the respective
regular expression constructs. However, the regular constructs for QREs are more
restrictive for QREs since the transformations made to the data by
canonizers and lenses involve matching the data against a regular expression
deterministic. Therefore to make these transformations deterministic, the
data should be matched uniquely against the regular expressions, and this
constrains the regular expressions that may be used by QREs. \dpw{This is not an
``example'' -- it is an informal description of how these operators work.}
\item
The $\normalize{R}{R'}{f}$ construct allows the programmer to choose how to
canonize $\mathcal{L}(R)$ into $\mathcal{L}(R')$ be providing the canonizing
function $f$ themselves. This constuct is useful when the desired equivalence
relation cannot easily be expressed by any of the other constructs.
  \end{enumerate}

\saz{Every regular expression $R$ is a QRE.  The main new syntactic
forms are:
$R \mapsto s$, which }

\saz{Would it be simpler to include atoms and $\epsilon$ in $q$ rather than $R$?  That is, $R$ is
  just a subset of $QRE$ built from atoms, $\cdot$ $|$ and ${}^*$.  We could
  reserve $R$ as a metavariable that ranges over $q$'s such that $q$ is a
  regular expression.}

\saz{Need to introduce $\mathcal{L}(R)$ notation.}

\iffalse
Quotient Regular Expressions (or QREs) enable us to give richer specifications
for data formats than ordinary regular expressions. More concretely,
  All data to be transformed must match $W(q)$, the ``whole'' regular
  expression of $q$. However, before transforming the using a lens, the data
  will be quotiented out by the equivalence relation $EqRel(q)$ which has $K(q)$
  as a complete set of representatives. That is, for each string $w \in
  W(q)$, there is a unique $k \in K(q)$ such that $w \; EqRel(q) \; k$). This
  unique representative $k$ is chosen using the ``canonizing'' function
  $\canonizer(q)$.
  \fi
  
\subsection{Semantics of QREs}
\subsubsection{Preliminaries}
As we mentioned earlier, when applying the regular constructs $\cdot
\; | \;  *$ to QREs, we require that the regular languages
described by QREs match the data in only one way so as to make
various transformations made to the data that involve matching the data against
a regular expression deterministic. Consequently, we require that regular
expressions used by QREs be \textit{strongly unambiguous}, a condition which
ensures that if a string $s$ matches a regular expression $R$, then $s$ matches
$R$ uniquely.

To this end, we say that regular expressions $R$ and $S$ are
\textit{unambiguosly concatenable}, written $R \cdot^! S$ if for all strings
$r, r' \in \mathcal{L}(R)$ and $s, s' \in \mathcal{L}(S)$, if $r \cdot s = r'
\cdot s'$, then $r = r'$ and $s = s'$. We say that a regular expression $R$ is
\textit{unambiguosly iterable}, written $R^{*!}$ if for all strings $r_1,
\ldots, r_m$ and $r'_1, \ldots, r'_n \in \mathcal{L}(R)$, if $r_1 \cdot \ldots
\cdot r_m = r'_1 \cdot \ldots \cdot r'_n$, then $m = n$ and $r_i = r'_i$.

We say that a regular expression $R$ is \textit{strongly unambiguous} if and
only if (1) $R = \varnothing$, or (2) $R = S_1 \cdot S_2$ with $S_1, S_2$
strongly unambiguous and $S_1 \cdot^! S_n$, or (3) $R = S_1 \sep S_2$ with
$S_1, S_2$ strongly unambiguous and $\mathcal{L}(S_1) \cap \mathcal{L}(S_2) =
\varnothing$, or (4) $R = S^*$ with $S$ strongly unambiguous and $S^{*!}$.

The semantics for QREs that formally define the whole language $W(q)$, the
kernel language $K(q)$, the equivalence relation $EqRel(q)$ and the
canonizing function $\canonizer(q)$ are given in Figures ~\ref{fig:wk},
~\ref{fig:relations} and ~\ref{fig:canonizers}.
\begin{figure}[t]
  \centering
  \[
    \begin{array}{l@{\quad}l@{\quad}l}
   
      q & W(q) & K(q) \\ \hline
      R & R & R \\
      R \mapsto s & W(q) & s \\
      \squash{R}{R'}{f} & R \sep R' & R' \\
      \normalize{R}{R'}{f} & R & R' \\
      q_1 \circ  q_2 & W(q_2) & K(q_1) \\
      q_1 \cdot q_2 & W(q_1) \cdot W(q_2) & K(q_1) \cdot K(q_2) \\
      q_1 \sep q_2 & W(q_1) \sep W(q_2) & K(q_1) \sep K(q_2) \\
      q^* & W(q)^* & K(q)^* \\
    \end{array}
  \]
\[
\begin{array}{r@{\quad}l}
W( \perm{q_1, \ldots, q_n}{q} ) = &
\bigcup \limits_{\sigma \in S_n} W(q_{\sigma(1)}) \cdot W(q) \cdot \ldots \cdot
W(q) \cdot W(q_{\sigma(n)})
\\
K( \perm{q_1, \ldots, q_n}{q} ) = &
 K(q_1) \cdot K(q) \cdot \ldots \cdot K(q) \cdot K(q_n) 
\end{array}
\]
  \caption{Whole and Kernel Regular Expressions\bcp{left-justify columns,
      and try putting the last two clauses into the same format as the
      others (using $\mathit{qq} = ...$ and maybe reducing spacing around
      cdots, etc.)}}
  \label{fig:wk}
\end{figure}

\begin{figure}[t]
  \centering
\[
    \begin{array}{l@{\quad}l@{\quad}l} 
      w \; \equiv_R \; w' &\iff& w = w \\
      w \; \equiv_{R \mapsto s} \; w' \text{ for all }w, w'\\
      w \; \equiv_{\squash{R}{R'}{f}} \; w' &\iff& f(w) = w'
      \text{ or } w = w' \\
      w \; \equiv_{\normalize{R}{R'}{f}} \; w' &\iff&
      f(w)=f(w') \text{ or }w = w'\\
      w \; \equiv_{q_2 \circ q_1} \; w' &\iff& \exists k, k' \in
  \mathcal{L}(K(q_2)) \text{ such that } w \; \equiv_{q_1} \; k, \; w' \;
  \equiv_{q_1} \; k', \text{ and } k \; \equiv_{q_2} \; k'\\
      w \; \equiv_{q_1 \cdot q_2} \; w'  &\iff& w = r_1
      \cdot r_2, \; w' = {r'}_1 \cdot {r'}_2 \text{ with } r_1 \; \equiv_{q_1}
      \; {r'}_1, \; r_2 \; \equiv{q_n} \; {r'}_2\\
      w \; \equiv_{q' \sep q} \; w' &\iff& w \; \equiv_{q_1} \; w'
      \text{ or } \; w \; \equiv_{q_2} \; w'\\
      w \; \equiv_{q*} \; w' &\iff& w = r_1 \cdot \ldots \cdot r_n, \; w'
      = {r'}_1 \cdot \ldots \cdot {r'}_n \text{ and } r_i \equiv_{q} \; {r'}_i
      \\
      w \; \equiv_{\perm{q_1, \ldots, q_n}{q}} \; w' &\iff& w = r_{\sigma(1)}
      \cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}, \;
    w' = {r'}_{\theta(1)} \cdot s'_1 \cdot \ldots \cdot s'_{n-1}
    \cdot {r'}_{\theta(n)} \\
    & & \text{ for some } \sigma, \theta \in S_n, \text{ with } r_i \;
    \equiv_{q_i} \; r'_i \text{ and } s_k \; \equiv_{q} \; s'_{k}
    \end{array}
    \]
  \caption{QRE Equivalence Relations}
  \label{fig:relations}
\end{figure}
\begin{figure}[t]
  \begin{center}
\[
    \begin{array}{l@\quad l @\quad l} 
      \canonizer(R) &=& id_{\mathcal{L}(R)} \\
      \canonizer(R \mapsto s)(w) &=& s\\
      \canonizer(\squash{R}{R'}{f})(w) &=& 
\begin{cases}
f(w) & \text{if } w \in \mathcal{L}(R)\\
w & \text{otherwise}
\end{cases}\\
      \canonizer(\normalize{R}{R'}{f}) &=& f\\
      \canonizer(q' \circ q) &=& \canonizer(q') \circ \canonizer(q)\\
      \canonizer(q' \cdot q) &=& \canonizer(q') \cdot \canonizer(q)\\
      \canonizer(q_1 \sep q_2)(w) &=& 
\begin{cases}
\canonizer(q_1)(w) & \text{if } w \in \mathcal{L}(W(q_1))\\
\canonizer(q_2)(w) & \text{if } w \in \mathcal{L}(W(q_2))\\
\end{cases}\\
      \canonizer(q^*) &=& \canonizer(q)^* \\
    \end{array}
    \]
    \end{center}
    $\canonizer(\perm{q_1, \ldots, q_n}{q})(r_{\sigma(1)}
\cdot s_1 \cdot \ldots \cdot s_{n-1} \cdot r_{\sigma(n)}) \newline
= (\canonizer(q_1)(r_1)) \cdot (\canonizer(q)(s_1)) \cdot \ldots \cdot
(\canonizer(q_n)(r_n))$
  \caption{QRE canonizers}
  \label{fig:canonizers}
\end{figure}
\begin{figure}[t]
\centering
\begin{prooftree}
\AxiomC{$R$ is strongly unambiguous}
\UnaryInfC{$\mathit{id}(R)$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$s \in W(q)$}
\UnaryInfC{$R \mapsto s$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R) \cap \mathcal{L}(R') = \varnothing$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\BinaryInfC{$squash(R, R', f)$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{${\substack{\forall \sigma \neq \theta, \; W(q_{\sigma(1)}) \cdot W(q)
\cdot \ldots \cdot W(q_{\sigma(n)})\\ \cap W(q_{\theta(1)}) \cdot W(q)
\cdot \ldots \cdot W(q_{\theta(n)}) =\varnothing}}$}
\AxiomC{$q_i, q$ are well formed}
\AxiomC{$\forall \sigma, \; K(q_{\sigma(1)}) \cdot^! K(q) \cdot^! \ldots 
\cdot^! K(q_{\sigma(n)})$}
\TrinaryInfC{$\perm{q_1, \ldots, q_n}{q}$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\mathcal{L}(R') \subseteq \mathcal{L}(R)$}
\AxiomC{$f : \mathcal{L}(R) \longrightarrow \mathcal{L}(R')$}
\AxiomC{$f$ is surjective}
\AxiomC{$f = f^2$}
\QuaternaryInfC{$normalize \; (R,R', f)$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$K(q) = W(q')$}
\TrinaryInfC{$q' \circ q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$W(q) \cdot^! W(q')$}
\AxiomC{$K(q) \cdot^! K(q')$}
\QuaternaryInfC{$q \cdot q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$q'$ is well formed}
\AxiomC{$W(q) \cap W(q') = \varnothing$}
\TrinaryInfC{$q \cdot q$ is well formed}
\end{prooftree}

\begin{prooftree}
\AxiomC{$q$ is well formed}
\AxiomC{$W(q)^{*!}$}
\AxiomC{$K(q)^{*!}$}
\TrinaryInfC{$q^*$ is well formed}
\end{prooftree}
  \caption{QRE Inference Rules\bcp{Maybe some or all of these can be
      suppressed in the ``short version'' of the paper}}
  \label{fig:qrerules}
\end{figure}
The theorem below confirms that the semantics of QREs are consistent with their
intended behaviour:
\begin{theorem}
If $q$ is a well formed QRE, then
\begin{enumerate}
  \item $W(q)$ and $K(q)$ are well defined regular expressions,
  \item  $EqRel(q)$ is an equivalence relation on $\mathcal{L}(W(q))$,
  \item  $\mathcal{L}(K(q))$ forms a complete set of representatives for
  $EqRel(q)$,
  \item $\canonizer(q):\mathcal{L}(W(q)) \longrightarrow \mathcal{L}(K(q))$ is a
  well-defined function, and
  \item  given any $w \in \mathcal{L}(W(q))$, $\canonizer(q)(w)$ is the unique
  $k$ in $\mathcal{L}(K(q))$ such that $k$ is equivalent to $w$ modulo
  $EqRel(q)$.
  \end{enumerate}
\end{theorem}

\section{QRE Lenses}
\label{QRE-lenses} 
As we have seen, QREs enable the programmer to express a regular expression $R$
as well as an equivalence relation on $\mathcal{L}(R)$. QREs are therefore a
good \textit{specification} language for quotient lenses. In this section of the
paper, we introduce \textit{QRE Lenses}. QRE lenses are quotient lenses based on
the Boomerang quotient lens combinators, but which use QREs to describe their
source and view types.

\subsection{Syntax of QRE Lenses}
\subsubsection{Preliminaries}
Given regular expressions $R, S$ and equivalence
relations $\sim_R, \sim_S$ defined on $\mathcal{L}(R)$ and $\mathcal{L}(S)$
respectively, a \textit{bijective quotient lens} $q :
R/{\sim_R}{\Longleftrightarrow} S/{\sim_S}$ from $R$ to $S$ is
a pair of functions $q.get:
\mathcal{L}(R) \longrightarrow \mathcal{L}(S)$ and $q.put : \mathcal{L}(S)
\longrightarrow \mathcal{L}(R)$ such that
\begin{align*}
q.put \; (q.get \; r) &\sim_R r\\
q.get \; (q.put \; s) &\sim_S s
\end{align*}
Additionally the components of $q$ must respect $\sim_R$ and $\sim_S$ i.e.
if $r \sim_R r'$ and $s \sim_S s'$ then $q.get \; r \; \sim_S q.get \; r'$
and $q.put \; s \sim_R q.put \; s' \; s'$.

Our approach in defining QRE lenses is as follows. Let $c, c'$ be QREs. Given a
bijection $\ell : K(c) \Leftrightarrow K(c')$, we may define a quotient lens $q
: W(c)/EqRel(c) \Leftrightarrow W(c')/EqRel(c')$ by
\begin{equation}\label{normalform}
q.get = \ell \circ \canonizer(c) \text{ and } q.put = \ell^{-1} \circ
\canonizer(c'),
\end{equation}

A potential problem with this approach is that quotient lenses of this form may
not necessarily be closed under the action of the lens combinators. For
example, these lenses may not be closed under composition, which is one of the
combinators we would want to have quotient lens language.

Consequently, in order to define quotient lenses, we need to choose a class of
bijections that has just the right properties with respect to the quotient
lens combinators. Our choice is to use the class of \textit{bijective
lenses} which we identified and studied in our previous work~\cite{popl18}.
Bijective lenses, which we briefly discuss in the next subsection, possess
the properties needed to ensure that all QRE lenses have the normal form
suggested in \cref{normalform}.

\subsection{Bijective Lenses}
We define the set of \textit{bijective lenses} to be the set of bijections
between regular languages created from Boomerang lens combinators.
The syntax for the language of bijective lenses is given by
$$\ell := \mathit{id} \; (R) \sep const(s, s') \sep  swap(\ell,
\ell) \sep \ell \cdot \ell' \; |  \; (\ell \sep \ell') \sep \ell^* \;
| \; \ell \circ \ell',$$ where $R$ ranges over regular expressions and $s$
ranges over character strings.

Â‘The denotation of a lens $\ell$ is $\llbracket \ell \rrbracket \subseteq
\mathit{String} \times \mathit{String}$. If $(s_1, s_2) \in \llbracket \ell
\rrbracket$, then $\ell$ maps between $s_1$ and $s_2$.

\begin{align*}
\llbracket R \rrbracket &= \{(r, r) \sep r \in \mathcal{L}(R)\}\\
\llbracket swap(\ell, \ell') \rrbracket &= \{(s \cdot t, t' \cdot s') \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \cdot \ell' \rrbracket &= \{(s \cdot t, s' \cdot t) \sep
(s, s') \in \llbracket \ell \rrbracket \text{ and } (t, t') \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell \sep \ell' \rrbracket &= \{(s \cdot t) \sep
(s, t) \in \llbracket \ell \rrbracket \text{ or } (s, t) \in \llbracket
\ell' \rrbracket\}\\
\llbracket \ell^* \rrbracket &= \{(s_1 \cdot \ldots \cdot s_n, t_1 \cdot \ldots
\cdot t_n) \sep (s_i, t_i) \in \llbracket \ell \rrbracket \text{ for } 1
\leq i \leq n\}
\end{align*}

The $\mathit{const}(s, t)$ lens replaces the string $s$ with $t$ in the source
data in the forward direction, and $t$ with $s$ in the view data in the backward
direction. $\mathit{id}(R)$ applies the identity function to the source and view
in $\mathcal{L}(R)$ in both directions. The composition lens $\ell' \circ \ell$
applies $\ell$ followed by then $\ell'$ to the source in the forward direction,
and applies $\ell'$ followed by $\ell$ to the view in the backward direction.
The lens $\ell \cdot \ell'$ first splits the string $s$ into $s_1$ and $s_2$,
applies $\ell$ and $\ell'$ to $s_1$ and $s_2$ to get $t_1$ and $t_2$
respectively, then concatenates $t_1$ and $t_2$ and returns $t_1 \cdot t_2$ as
the final result in the forward direction. $\ell \cdot \ell'$ operates
similarly in the backward direction, but with $s, s_1$ and $s_2$ substituted
for $t, t_1$ and $t_2$. The $\mathit{swap} \; (\ell, \ell')$ lens operates
like $\ell \cdot \ell'$, except that it swaps $t_1$ and $t_2$ before
concatenating the two for a final result of $t_2 \cdot t_1$ in the forward
direction. In the backward direction, $\mathit{swap}(\ell, \ell')$ first undoes
the swap, then proceeds as expected. The $\ell \; | \; \ell'$ lens
chooses to apply $\ell$ or $\ell'$ depending on whether the source
(resp. view) data is matched by $\ell$ or $\ell'$ in the forward (resp.
backward direction. The $\ell^*$ lens splits the string $s$ into strings $s_1,
\ldots, s_n$, applies $\ell$ to each $s_i$ to get $t_i$, and then concatenates
each of the $t_i$'s for a final result of $t_1 \cdot \ldots \cdot t_n$ in the
forward direction. $\ell^*$ operates similarly in the backward direction, but
with $s, s_i$ substituted for $t, t_i$.

Each bijective lens $\ell$ has a type $\ell : R \Leftrightarrow S$ where $R$ and
$S$ are regular expressions. If $\ell : R \Leftrightarrow S$, then the source
type of $\ell$ is $\mathcal{L}(R)$ and the view type of $\ell$ is
$\mathcal{L}(S)$. Interestingly, with the bijective lens type system, a lens
$\ell : R \Leftrightarrow S$ can also be considered to be of type $\ell : R'
\Leftrightarrow S'$ provided that $R$ (resp. $S$) can be proven to be
equivalent to $R'$ (resp. $S$) from the star-semiring axioms. The typing rules
for bijective lenses are given in Figure~\ref{fig:lensrules}. 

 \begin{figure}[t]
  \begin{prooftree}
\AxiomC{$s_1 \in \Sigma^*$}
\AxiomC{$s_2 \in \Sigma^*$}
\BinaryInfC{$\mathit{const} \; (s_1, s_t): s_1 \Leftrightarrow s_2$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$R$ is strongly unambiguous}
\UnaryInfC{$\mathit{id} \; (R): R \Leftrightarrow R$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
\AxiomC{$R_1 \cdot^! R_2$}
\AxiomC{$S_1 \cdot^! S_2$}
\QuaternaryInfC{$\ell_1 \cdot \ell_2: R_1 \cdot R_2 \Leftrightarrow S_1 \cdot
S_2$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow R_2$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow R_3$}
\BinaryInfC{$\ell_2 \circ \ell_1: R_1 \Leftrightarrow R_3$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
\AxiomC{$R_1 \cdot^! R_2$}
\AxiomC{$S_2 \cdot^! S_1$}
\QuaternaryInfC{$\mathit{swap} \; (\ell_1, \ell_2): R_1 \cdot R_2
\Leftrightarrow S_2 \cdot S_1$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell_1 : R_1 \Leftrightarrow S_1$}
\AxiomC{$\ell_2 : R_2 \Leftrightarrow S_2$}
\AxiomC{$\mathcal{L}(R_1) \cap \mathcal{L}(R_2) = \varnothing$}
\AxiomC{$\mathcal{L}(S_1) \cap \mathcal{L}(S_2) = \varnothing$}
\QuaternaryInfC{$\ell_1 \sep \ell_2: R_1 \sep R_2 \Leftrightarrow S_1 \sep S_2$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R^{*!}$}
\AxiomC{$S^{*!}$}
\TrinaryInfC{$\ell^*: R \Leftrightarrow S$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\ell : R \Leftrightarrow S$}
\AxiomC{$R \equiv R'$}
\AxiomC{$S \equiv S'$}
\TrinaryInfC{$\ell : R' \Leftrightarrow S'$}
\end{prooftree}
  \caption{Bijective Lens Typing Rules}
  \label{fig:lensrules}
\end{figure}

\subsection{Syntax of QRE Lenses}
Having described the class of bijective lenses, we now introduce the class
of QRE lenses, whose language is given by following grammar:
$$ q := \mathit{lift}(\ell) \sep \mathit{lquot}(q, \ell) \sep
\mathit{rquot}(\ell, q) \sep q \cdot q' \sep (q \sep q') \sep q^* \sep q \circ q',$$
where $\ell$ ranges over bijective lenses.

The QRE lens combinators are inspired by the Boomerang lens combinators of the
same name. The $\mathit{lift}(\ell)$ quotient lens enables a bijective lens
$\ell$ to be considered a quotient lens where the equivalence relation applied
to the source and view types is the equality relation. The $\mathit{lquot}(c,
q)$ combinator takes a quotient lens $q$ and quotients the source data using
$c$, assuming that the source data forms a complete set of representatives for
the equivalence relation $EqRel(c)$. The $\mathit{lquot}(q, c)$ does the same
but on the view data. The regular combinators $\cdot \; * \; |$ exhibit the
expected behaviour. \sam{Examples needed?}

The difference between QRE lenses and Boomerang quotient lenses is the typing
judgements. More concretely, each QRE lens $q$ has a type $q : c \Leftrightarrow
c'$ where $c, c'$ are QREs. In contrast, the approach used to type quotient
lenses in Boomerang is to classify equivalences according to whether they are
or are not the equality relation. This type system is based on two
observations: first, that most quotient lenses originate as lifted basic
lenses, and therefore have types whose equivalence relations are both equality;
and second, that equality is preserved by many of the quotient lens
combinators. Foster et al also discuss a second possible approach to typing
quotient lenses, where equivalence relations are represented by rational
functions that induce them. While this second approach is more refined than the
first, Boomerang favours the first approach since the second appears to be too
expensive to be useful in practice~\cite{quotientlenses}.

\subsection{Semantics of QRE Lenses}
As we mentioned earlier, every quotient lens $q$ has a type $q :
c \Longleftrightarrow c'$ where $c$ and $c'$ are QREs. The denotation
$\llbracket q \rrbracket$ of a QRE lens $q:c \Leftrightarrow c'$ is a quotient
lens $\llbracket q \rrbracket : W(c)/{EqRel(c)} \Longleftrightarrow
W(c')/{EqRel(c')}$. The typing rules and denotation of QRE lenses are given in
Figure~\ref{fig:qlenssemantics}. The following theorem confirms that QRE lenses
exhibit the intended behaviour.

\begin{theorem}
If there is a derivation $q:c \Leftrightarrow c'$ then
$\llbracket q \rrbracket : W(c)/EqRel(c) \Leftrightarrow W(c')/EqRel(c')$ is a
well-defined quotient lens.
\end{theorem}

 \begin{figure}[t]
  \centering
  \begin{prooftree}
\AxiomC{$\ell : R \Leftrightarrow S$}
\UnaryInfC{$\mathit{lift}(\ell): R \Leftrightarrow id(S)$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &=  \llbracket \ell \rrbracket, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1}
  \end{align*}
 
\begin{prooftree}
\AxiomC{$q' : c'  \Leftrightarrow c''$}
\AxiomC{$c$ is well formed}
\AxiomC{$K(c) = W(c')$}
\TrinaryInfC{$\mathit{lquot}(c, q'): c' \circ c \Leftrightarrow c''$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get  &= \llbracket q'
  \rrbracket.get \circ \canonizer(c)\\
  \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
  \end{align*}

  \begin{prooftree}
  \AxiomC{$q' : c \Leftrightarrow c'$}
  \AxiomC{$c''$ is well formed}
  
\AxiomC{$K(c'') = W(c')$}
\TrinaryInfC{$\mathit{rquot}(q', c):c \Leftrightarrow c'' \circ c'$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q'
  \rrbracket.get\\
  \llbracket q \rrbracket.put &= \llbracket q'
  \rrbracket.put \circ \canonizer(c'')
  \end{align*}
  
  \begin{prooftree}
\AxiomC{$q_1 : c \Leftrightarrow c'$}
\AxiomC{$q_2 : c' \Leftrightarrow c''$}
\BinaryInfC{$q_2 \circ q_1: c \Leftrightarrow c''$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
  q_1 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
  q_2 \rrbracket.put
  \end{align*}

    \begin{prooftree}
\AxiomC{$q' : c \Leftrightarrow c'$}
\AxiomC{$W(c)^{*!}$ and $W(c')^{*!}$}
\AxiomC{$K(c)^{*!}$ and $K(c')^{*!}$}
\TrinaryInfC{${q'}^* : c^* \Leftrightarrow {c'}^*$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
  and }\\
  \llbracket q \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
  \end{align*}

    \begin{prooftree}
\AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
\AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
\AxiomC{${\substack{W(c_1) \cdot^! W(c_2)\\ K(c_1) \cdot^! K(c_2)}}$}
\AxiomC{${\substack{W(d_1) \cdot^! W(d_2)\\ K(d_1) \cdot^! K(d_2)}}$}
\QuaternaryInfC{$q_1 \cdot q_2: c_1 \cdot c_2
\Leftrightarrow d_1 \cdot d_2$}
\end{prooftree}
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
  q_2 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
  q_2 \rrbracket.put
  \end{align*}

      \begin{prooftree}
\AxiomC{$q_1 : c_1 \Leftrightarrow d_1 $}
\AxiomC{$q_2 : c_2 \Leftrightarrow d_2$}
\AxiomC{$\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) = \varnothing$}
\AxiomC{$\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$}
\QuaternaryInfC{$q_1 \sep q_2: (c_1 \sep c_2)
\Leftrightarrow (d_1 \sep d_2)$}
\end{prooftree}
  $$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
  \end{cases}$$
  $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
  \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
  \end{cases}
  $$
  \caption{Denotation and Typing Rules for QRE Lenses}
  \label{fig:qlenssemantics}
\end{figure}

\subsection{Normal Forms QRE Lenses}
Recall that our approach in defining QRE lenses is to have each QRE lens $q: c
\Leftrightarrow c'$ be such that 
\begin{align*}
\llbracket q \rrbracket.get &= \ell \circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \ell^{-1} \circ
\canonizer(c')
\end{align*}
for some bijective lens $\ell$. We now provide a proof that all QRE lenses are
of this form.
\begin{theorem}\label{normal form}
If there is a derivation $q : c \Leftrightarrow c'$, then there exists a
bijective lens $\ell : K(c) \Leftrightarrow K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c')
\end{align*}
\end{theorem}
\begin{proof}
Assume that $q : c \Leftrightarrow c'$. We proceed by induction over the
derivation $q : c \Leftrightarrow c'$.
\begin{enumerate}
  \item
  $\mathit{lift}(\ell): R/\mathit{id}(R) \Leftrightarrow S/\mathit{id}(S)$ where
  $\ell :
  R \Leftrightarrow S$. Then
  \begin{align*}
  \llbracket \mathit{lift}(\ell) \rrbracket.get &=  \llbracket \ell \rrbracket
  = \llbracket \ell \rrbracket \circ id_{\mathcal{L}(R)} =
  \llbracket \ell \rrbracket \circ \canonizer(\mathit{id}(R)), \text{ and }\\
  \llbracket \mathit{lift}(\ell) \rrbracket.put &= \llbracket \ell
  \rrbracket^{-1} = \llbracket \ell \rrbracket^{-1} \circ id_{\mathcal{L}(S)} =
  \llbracket \ell \rrbracket^{-1} \circ \canonizer(id(S))
  \end{align*}
  \item
  $\mathit{lquot}(c, q'): c' \circ c \Leftrightarrow c''$ where $q' : c' 
  \Leftrightarrow c''$, $c$ is well formed and $K(c) = W(c')$. Then
\begin{align*}
  \llbracket q \rrbracket.get  &= \llbracket q'
  \rrbracket.get \circ \canonizer(c)\\
  \llbracket q \rrbracket.put &= \llbracket q' \rrbracket.put
  \end{align*}
  By the induction hypothesis, there exists a bijective lens $\ell :
  K(c') \Leftrightarrow K(c'')$ such that 
  \begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ \canonizer(c')\\
\llbracket q' \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
Canonize(c'')
\end{align*}
Consequently
\begin{align*}
  \llbracket q \rrbracket.get  &= (\llbracket \ell \rrbracket \circ
  \canonizer(c')) \circ \canonizer(c) = \llbracket \ell \rrbracket \circ
  (\canonizer(c' \circ c))\\
  \llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
  Canonize(c'')
  \end{align*}

  \item
  $\mathit{rquot}(q', c''):c \Leftrightarrow c'' \circ c'$ where $q' : c \Leftrightarrow
  c'$, $c''$ is well formed and $K(c'') = W(c')$. Proceed as in the previous
  case.
\item
$q_2 \circ q_1: c \Leftrightarrow c''$ where $q_1 : c \Leftrightarrow c'$ and
$q_2 : c' \Leftrightarrow c''$. Then
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_2 \rrbracket.get\circ \llbracket
  q_1 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \circ \llbracket
  q_2 \rrbracket.put
  \end{align*}
  By the induction hypothesis, there exist bijective lenses
  $\ell_1 :
  K(c) \Leftrightarrow K(c')$ and $\ell_2 : K(c') \Leftrightarrow K(c'')$ such
  that
  \begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(c')
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
Canonize(c')\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
Canonize(c'')
\end{align*}
Consequently,
\begin{align*}
\llbracket q_2 \rrbracket.get \circ \llbracket q_1 \rrbracket.get &=
(\llbracket \ell_2 \rrbracket \circ \canonizer(c')) \circ (\llbracket \ell_1
\rrbracket \circ \canonizer(c))\\
&= \llbracket \ell_2 \rrbracket \circ (\canonizer(c') \circ \llbracket \ell_1
\rrbracket) \circ \canonizer(c)\\
&= (\llbracket \ell_2 \rrbracket \circ \llbracket \ell_1 \rrbracket) \circ
\canonizer(c)\\
&= \llbracket \ell_2  \circ  \ell_1 \rrbracket \circ
\canonizer(c)
\end{align*} 
A similar argument shows that 
$$\llbracket q_1 \rrbracket.put \circ \llbracket q_2 \rrbracket.put =
\llbracket \ell_2  \circ  \ell_1 \rrbracket^{-1} \circ
\canonizer(c)$$
\item  
${q'}^* : c^* \Leftrightarrow {c'}^*$ where $q' : c \Leftrightarrow c'$,
$W(c)^{*!}$ and $W(c')^{*!}$ and $K(c)^{*!}$ and $K(c')^{*!}$. Then
  \begin{align*}
  \llbracket {q'}^* \rrbracket.get &= (\llbracket q' \rrbracket.get)^*, \text{
  and }\\
  \llbracket {q'}^* \rrbracket.put &= (\llbracket q' \rrbracket.put)^*
  \end{align*}
  By the induction hypothesis there exists a bijective lens $\ell : K(c)
  \Leftrightarrow K(c')$ such that 
   that
  \begin{align*}
\llbracket q' \rrbracket.get &= \llbracket \ell \rrbracket \circ
\canonizer(c)\\
\llbracket q' \rrbracket.put &= {\llbracket \ell \rrbracket}^{-1} \circ
\canonizer(c')
\end{align*}
Consequentlty
\begin{align*}
\llbracket {q'}^* \rrbracket.get &= (\llbracket \ell \rrbracket \circ
\canonizer(c))^* = \llbracket \ell \rrbracket^* \circ
\canonizer(c)^* = \llbracket \ell^* \rrbracket \circ
\canonizer(c^*)\\
\llbracket {q'}^* \rrbracket.put &= (\llbracket \ell \rrbracket^{-1} \circ
\canonizer(c'))^* = (\llbracket \ell \rrbracket^{-1})^* \circ
\canonizer(c')^* = \llbracket \ell^* \rrbracket^{-1} \circ
\canonizer(c'^*)\\
\end{align*}
\item
  $q_1 \cdot q_2: c_1 \cdot c_2 \Leftrightarrow d_1 \cdot d_2$, where $q_1 : c_1
  \Leftrightarrow d_1 $,  $q_2 : c_2 \Leftrightarrow d_2$, $W(c_1)
  \cdot^! W(c_2)$, $K(c_1) \cdot^! K(c_2)$, $W(d_1) \cdot^! W(d_2)$ and $
  K(d_1) \cdot^! K(d_2)$. Then
  \begin{align*}
  \llbracket q \rrbracket.get &= \llbracket q_1 \rrbracket.get \cdot \llbracket
  q_2 \rrbracket.get, \text{ and }\\
  \llbracket q \rrbracket.put &= \llbracket q_1 \rrbracket.put \cdot \llbracket
  q_2 \rrbracket.put
  \end{align*}
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
\begin{align*}
  \llbracket q \rrbracket.get &= (\llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)) \cdot  (\llbracket \ell_2 \rrbracket \circ
\canonizer(c_2))\\
&= (\llbracket \ell_1 \rrbracket \cdot \llbracket \ell_2
\rrbracket) \circ (\canonizer(c_1) \cdot \canonizer(c_2))\\
&= \llbracket \ell_1 \cdot  \ell_2 \rrbracket \circ \canonizer(c_1 \cdot c_2)
\end{align*}
Similarly
$$
  \llbracket q \rrbracket.put = \llbracket \ell_1 \cdot  \ell_2 \rrbracket^{-1}
  \circ \canonizer(d_1 \cdot d_2) $$
  \item
  $q = q_1 \sep q_2$ where $q_1 : c_1 \Leftrightarrow d_1 $, $q_2 : c_2
  \Leftrightarrow d_2$, $\mathcal{L}(W(c_1)) \cap \mathcal{L}(W(c_2)) =
  \varnothing$ and $\mathcal{L}(W(d_1)) \cap \mathcal{L}(W(d_2)) = \varnothing$.
  Then
  $$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket q_2 \rrbracket.get (s) & \text{if } s \in \mathcal{L}(W(c_2))\\
  \end{cases}$$
  $$\llbracket q_1 \sep q_2 \rrbracket.put(s) = 
  \begin{cases}
  \llbracket q_1 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_1))\\
  \llbracket q_2 \rrbracket.put (s) & \text{if } s \in \mathcal{L}(W(d_2))\\
  \end{cases}
  $$
By the induction hypothesis, there exist bijective lenses $\ell_1 : K(c_1)
\Leftrightarrow K(d_1)$ and $\ell_2 : K(c_2) \Leftrightarrow K(d_2)$ such that
\begin{align*}
\llbracket q_1 \rrbracket.get &= \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1)\\
\llbracket q_1 \rrbracket.put &= {\llbracket \ell_1 \rrbracket}^{-1} \circ
\canonizer(d_1)
\end{align*}
and
\begin{align*}
\llbracket q_2 \rrbracket.get &= \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2)\\
\llbracket q_2 \rrbracket.put &= {\llbracket \ell_2 \rrbracket}^{-1} \circ
\canonizer(d_2)
\end{align*}
Consequently,
$$
  \llbracket q_1 \sep q_2 \rrbracket.get(s) = 
  \begin{cases}
  \llbracket \ell_1 \rrbracket \circ
\canonizer(c_1) (s) & \text{if } s \in \mathcal{L}(W(c_1))\\
  \llbracket \ell_2 \rrbracket \circ
\canonizer(c_2) (s) & \text{if } s \in \mathcal{L}(W(c_2)),\\
  \end{cases}$$
  so $\llbracket q_1 \sep q_2 \rrbracket.get = \llbracket \ell_1 \sep
  \ell_2 \rrbracket \circ \canonizer(c_1 \sep c_2)$. A similar argument shows
  that $\llbracket q_1 \sep q_2 \rrbracket.put = \llbracket \ell_1 \sep
  \ell_2 \rrbracket^{-1} \circ \canonizer(d_1 \sep d_2)$.\\
  This completes the proof.
\end{enumerate}
\end{proof}

\section{Synthesizing QRE Lenses}
\label{synth}
By Theorem~\ref{normal form}, if there is a derivation $q : c \Leftrightarrow
c'$ of a QRE lens, then there exists a bijective lens $\ell : K(c)
\Leftrightarrow K(c')$ such that
\begin{align*}
\llbracket q \rrbracket.get &= \llbracket \ell \rrbracket\circ \canonizer(c)\\
\llbracket q \rrbracket.put &= \llbracket \ell \rrbracket^{-1} \circ
\canonizer(c')
\end{align*}


Now suppose that we wish to synthesize a quotient lens $q$ of type $q: c
\Leftrightarrow c'$ that maps a specified set of input strings to a
specified set of output strings and vice versa.

For example, in the \textsc{Bib}\TeX\ to EndNote problem, the programmer wishes
to synthesize a QRE lens $q$ which maps the QRE
$$\perm{\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},
\re{YEAR}}{(\re{WHITESPACE}^* \mapsto \string \n)}$$ 
to the QRE
$$\perm{\re{REF'}, \re{AUTHOR'}, \re{TITLE'}, \re{PUBLISHER'},
\re{YEAR'}}{(\re{WHITESPACE}^* \mapsto \string \n)}$$
where $\re{REF}, \re{AUTHOR}, \re{TITLE}, \re{PUBLISHER},$ and $\re{YEAR}$
(resp. $\re{REF'}, \re{AUTHOR'}, \re{TITLE'}, \re{PUBLISHER'},$ and
$\re{YEAR'}$) are regular expressions describing the respective
\textsc{Bib}\TeX\; (resp. EndNote) fields of the same name, and
$\re{WHITESPACE}$ is a regular expression describing whitespace
characters. Morever, the synthesized lens should map the equivalence
class of this \textsc{Bib}\TeX\; record
\begin{verbatim}
@Book {conway,
  Author = {Conway, J. H.},
  Title = {Regular Algebra and Finite Machines},
  Publisher = {Printed in GB by William Clowes & Sons Ltd},
  Year = {1971}
}
\end{verbatim}
\noindent to the equivalence class of this EndNote entry:
\begin{verbatim}
%0 Book
%T Regular Algebra and Finite Machines
%A Conway, J. H.
%D 1971
%I Printed in GB by William Clowes & Sons Ltd
%F conway
\end{verbatim}

In our previous work, we showed that given regular expressions $R, S$ and a set
of input-output pairs $\{(r_1, s_1), \ldots, (r_n, s_n)\}$, if there is a
derivation $\ell :, R \Leftrightarrow S$ of a bijective lens that maps $r_i$ to
$s_i$ in the forward direction and $s_i$ to $r_i$ in the backward direction,
then there is an algorithm that computes a bijective lens $\ell' : R'
\Leftrightarrow S'$ such that $R \equiv R'$, $S \equiv S'$, $\ell'$ maps $r_i$
to $s_i$ in the forward direction and $s_i$ to $r_i$ in the backward
direction, and $\llbracket \ell \rrbracket = \llbracket \ell'
\rrbracket$~\cite{popl18}.

\section{Implementation and Evaluation}
\label{impl}

\section{Related Work}
\label{relwork}

\bcp{Make sure to list/discuss:
  \begin{itemize}
  \item Seminar papers on lenses (to which we can refer readers for further
  reading about connections to view updates, etc.) and quotient lenses.
  \item Discuss what other lens-like programming languages (besides
  boomerang) do about quotienting.  E.g., Augeas, XSugar, ...
  \item How quotient lenses are used in Boomerang.
  \item Search for papers that cite the quotient lens paper and see if they
  extend the ideas there.
  \end{itemize}
}

\section{Conclusion and Future Work}
\label{concl}

\end{document}
